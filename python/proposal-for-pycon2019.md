## 문제제기

---

  파이썬을 처음 공부하면 sum 함수와 max, min 함수는 아마 반드시 써보기 마련입니다. 제가 처음 공부하면서 이 세 함수를 막연하게 '아하, `이 함수들은 리스트나 튜플을 한 번씩 돌면서`, 모든 값을 더하거나/ 최대값을 구하거나/ 최소값을 구하는 함수들이구나~' 라고 순진하게 생각했습니다. 그러니까 비슷한 부류라고 생각했던거죠. 그런데 sum과 나머지 함수의 동작방식에서 차이가 있다는 것을 발견합니다.

```python
>>> max([1, 2, 3, 4])  # 1.
>>> sum([1, 2, 3, 4])  # 2.
>>> max(1, 2, 3)        # 3.
>>> sum(1, 2, 3)        # 4.
```

아시다시피, 4번은 동작하지 않습니다. 저는 이게 너무 이상하다고 생각했습니다. 

'그래, 애초에 함수가 인자를 하나만 받게 한다고 정의했으면 3번과 4번이 안 되는 건 맞아. 근데 그러면 4번이 안 되면 3번도 똑같이 안 되어야 하는거 아냐?'

  **왜 sum은 입력을 iterable로 단 한 개만 받는지, 어떻게 max(min)는 입력을 여러 개, 심지어는 무한히 많이 받을 수 있는지 정말 궁금했고 많이 고민했습니다.** 결국 packing과 unpacking을 공부하고 나서야 그 의미를 알 수 있었습니다. 그리고 이를 통해 달성될 수 있는 신축성은 프로그램의 재사용성으로도 연결될 수 있다는 공학적이고 철학적인 /깨달음도 얻었습니다. 단순히 **파이썬 기본지식을 넘어서 제가 느낀 것들을 모두 공유하고 싶습니다.**



## 발표 내용:

---

이 발표의 대상 청중은 파이썬의 함수 정의와 사용에 문제가 없는 '초급자'입니다. 타 언어의 오버로딩 역할을 맡는, 기본 내용인 파이썬의 packing, unpacking을 소개합니다. 제 발표는 크게 두 부분으로 나뉩니다.

먼저 Packing, Unpacking의 기본적인 정의와 역할, 사용방법을 다룹니다.

그리고 이것을 활용한 예제를 두 개 정도 사용해 이들의 유용성을 입증하고 파이썬으로 프로그래밍을 처음 접하는 코더들에게 향후 소프트웨어 공학적인 질문을 스스로 던질 수 있도록 이끌 예정입니다.

각 부분에서 제가 생각하는 발표 내용은 다음과 같습니다.

### 1. Packing & Unpacking에 대한 기본 이해

1.1. 문제 제기(앞서 설명한 예시를 들 예정입니다). 그리고 타 언어의 오버로딩을 짧게 정의합니다.
1.2. 함수에 앞서 변수 할당에 있어 '*'를 통한 Unpacking을 먼저 살펴봅니다.(ex a, *b = [1,2,3])
1.3. 본격적인 함수에서의 packing과 unpacking을 소개합니다. '*'과 '**'는 함수 정의부에 쓰이는지, 함수 호출부에 쓰이는지에 따라 packing, unpacking으로 나뉘는데 이를 이해하는 것이 핵심입니다. 또한 '*'의 개수에 따라 Sequence, Mapping을 다루는지의 여부도 달라지죠. 이것도 살펴봅니다.
1.4. packing & unpacking과 관련한 간단한 트릭을 조금 살펴봅니다. 특히 '*'를 통해 입력인자들의 중요도에 따른 차별적인 실행이 가능한데 이 트릭도 살펴봅니다.

### 2. Packing & Unpacking의 예제 2개와 함께 '프로그래머'로서 한 단계 더 발전할 수 있도록 합니다.

2.1. 앞서 max와 sum의 작동방식이 다르다고 이야기했습니다. max는 인자가 1개일 때는 Iterable로 취급해 이중 최대값을 찾고, 2개 이상일 때는 ('>, <, =' 연산을 지원하는) 각 인자의 대소관계를 비교해 최대값을 찾습니다. 이때 max의 입력에 따른 이 이중적인 작동방식의 장단점에 대해 논합니다.

* 장점은 프로그램의 'Robustness'가 증가합니다. '사용자는 사악한 사람들이다.'라는 격언을 좋아하는데 파이썬 문법에 익숙하지 않은 초보자들이 최적이 아닌, 다양한 형태의 입력을 넣을 때(아까 예의 저처럼) 에러가 발생하지 않고 대응 가능성이 증가합니다.(Robust)
* 단점은 리눅스의 철학이라고도 할 수 있는 'Modularity'가 감소합니다. '한 가지 프로그램이 한 가지 일만을 잘 할 수 있도록 하라'라고도 표현할 수 있겠는데, max는 최대값을 찾겠다는 일념 아래 입력에 따라 서로 다른 작업을 하고 있습니다.(물론 실제 구현에서는 max는 wrapper일 것 같습니다)
결국 선택은 장점과 단점의 tradeoff의 문제일 것입니다. 프로그램 작성 시 이 둘 사이의 고민을 한다는 것을 공유하고 싶습니다.


2.2. 말이 길었는데 그래서 첫 번째 예제는 쉬운 예제로 packing, unpacking을 통해 max처럼 입력의 크기에 따라 실행 동작이 바뀌는 my_sum을 한 번 만들어봅니다.

두 번째 예제에서는 보다 의미 있는 문제로 유명한 알고리즘 연습문제인 FizzBuzz 문제를 원하는 기존의 'Fizz', 'Buzz'만이 아닌, 사용자의 입력에 따라 확장 가능하도록 하는 flexible_fizzbuzz 함수를 고안합니다. 이 함수는 숫자 n과 (숫자, 단어)쌍을 받아 1부터 n까지의 fizzbuzz word를 출력합니다. packing을 사용해 (숫자, 단어)쌍은 사용자가 원하는 개수만큼 입력받을 수 있게 합니다.

기존 If 문으로 작성하는 FizzBuzz 풀이는 쌍이 3개만 되어도 분기가 8번이 되기 때문에 하드코딩의 비효율성을 지적하며 알고리즘을 도입해 문제를 해결합니다. 또 원 문제를 '임의의 숫자에 대해 fizzbuzz word 생성'과 '1부터 n까지 fizzbuzz word 생성'이라는 두 가지 문제로 나눠 생각할 수 있도록 하며 SoC의 개념을 소개하고 원 문제를 나누는 습관의 중요성을 강조합니다. 또 이전 if 문 하드코딩에 비해 알고리즘을 통한 fizzbuzz 구현이 재사용성이 훨씬 뛰어나다는 것을 강조하며 "Don't reinvent the wheel"의 위트 있는 격언도 소개할 생각입니다. 

코드는 작성했는데 다음과 같습니다.

```python
def flexible_fizzbuzz(n, *items):
    """Print extensible fizzbuzz word from 1 to given n.

    :input:
        n: int | 1부터 사이에 정수들에 단어를 만들 값의 상한
	items: tuple | 약수와 해당 약수로 나누어질 때의 단어의 튜플. DEFAULT: ((3, 'Fizz'), (5, 'Buzz'))
    :return:
        1부터 n까지 fizzbuzz 단어를 한 줄씩 출력.
    """

    N = len(items)
    if not items:
        items = ((3, 'Fizz'), (5, 'Buzz'))

    # Subproblem 1. 한 숫자에 대해 단어 만들기
    def generate(n, i, tmp_str):
        if i == N:
            return tmp_str if tmp_str else n
        m, word = items[i]
        m = int(m)
        if n % m == 0:
            ans = generate(n, i+1, tmp_str+word)
        else:
            ans = generate(n, i+1, tmp_str)
        return ans

    # Subproblem 2. [1, n] 구간에 대해 순회하며 단어 출력하기
    for i in range(1, n+1):
        print(generate(i, 0, ''))
```


## 시간 배분

---

아무리 파이썬이 고급 언어라고 해도, 비전공자로서 파이썬을 공부하는 것이 쉬운 것만은 아닌 것 같습니다. 언어 자체를 익히는 것도 쉽지는 않지만 그것보다 절 더 힘들게 한 것은 더 나은 코드를 위한 철학을 공부하기가 쉽지 않다는 점입니다. 사실 이는 지금도 힘듭니다.

그래서 1번과 2번 모두 중요한데 2번에 저는 집중하고 싶습니다. 함수를 작성하고 사용하는 데 무리가 없는 파이썬 초급 유저에게는 packing과 unpacking은 이해하기에 매우 어려운 것은 아니고, 또 관련 포스트는 많기 때문입니다. 하지만 1번에 대한 설명이 부족하지는 않도록 꼭 주의하겠습니다.

시간 배분은 1번을 10 ~ 20분, 2번을 20 ~ 30분 정도 발표하고 싶습니다. 물론 구체적으로 자료 준비하면서 변경될 가능성도 있습니다.
