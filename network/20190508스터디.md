# 프로세스란?

한마디로 정의해서 **프로그램을 실행하기위해, 자원이 할당된, 커널의 정의한 추상적인 존재**다. 그렇다면 정확하게 무슨 자원이 할당되는지, 어떻게 할당되는지, 구성은 어떻게 되는지 하나씩 차근차근 알아보자.

## 메모리 자원(세그먼트와 가상 메모리)

프로세스는 실행시, 크게 4가지 영역으로 구분된 메모리를 할당받는다. 이렇게 구분된 단위를 **Segment** 라고 하며, 필요에 따라서 각 세그먼트의 크기는 커지기도 하고, 늘어나기도 한다.

그리고, 프로세스는 커널이 만들어낸 착각속에서 살고 있다는 사실을 알고 있나? 이론적으로, 프로세스는 자신이 컴퓨터가 활용할 수 있는 모든 메모리 주소에 접근할 수 있다. (물론 커널이 할당해준 주소 범위에서 벗어난 주소나 허가되지 않은 영역에 접근하려고 하면 Segmentation Fault Error를 발생하며 강제로 종료당한다.)

### 세그먼트
세그먼트는 4가지 영역으로 구성되어 있다. 각각은 다음과 같다.

* Code(Text) 영역
* Data 영역
* Stack 영역
* Heap 영역

Code(Text)영역은 말 그대로 프로그램을 실행하기 위해서 프로그래머가 작성한 코드를 컴퓨터가 해석할 수 있는 방식으로 번역된 데이터가 들어있다. 특징으로는 실행되기 전에 그 크기가 고정된다. 실행중인 프로그램의 코드가 늘어나거나 줄어들지는 않기 때문이다. 

Data영역은 전역변수, Static 키워드가 붙은 변수들이 저장되는 영역이다. 이 영역은 Code영역과 마찬가지로 프로그램이 실행되기 전에 그 크기가 고정된다. GCC같은 컴파일러 콜렉션은 프로그래머가 이미 어떤 변수들을 Code영역에 놓았는지 전부 파악하고 있기 때문이다.

Stack영역은 독특하다. 이미 정의된 스택영역의 한계치가 설정되어 있지만(이 영역을 넘어서서 Stack 메모리가 할당되면 그 유명한 Stack Overflow Error가 발생한다.), Stack 영역이 사용하는 메모리의 양은 실행되고 있는 프로그램의 상황에 따라서(즉, 함수 호출과 반환등의 상황을 반영) 가변적이다. 스레드와도 깊은 연관성이 있지만 이는 아래에서 스레드 관련된 글에서 적도록 하겠다.

Heap영역도 Stack영역과 마찬가지로 프로그램 실행전에 이미 한계치가 정해져 있지만 가용 메모리는 프로세스의 상태에 따라서 변한다. 그리고 이 한계치를 넘어가면 OOME(Out of Memory Error)를 만나게 될 것이다. 

여기서 프로세스에 할당되는 4가지 세그먼트 영역에 대해서 간략하게 살펴보았지만, 다른 영역이 왜 필요한지는 알아도 Heap영역이 왜 필요한지는 잘 모르는 사람들이 많다. 여기서 Heap영역이 왜 필요한지 자세하게 짚고 넘어가자.

#### Heap 영역은 왜 필요한 것인가?

힙이 필요한 이유는, 다시 말해서 동적할당이 필요한 이유로 말할 수 있다. 

* Glossaries를 참고하라.
### 가상 메모리

앞서 말했듯이, 프로세스는 자신을 실행시키고 있는 컴퓨터의 모든 메모리 자원에 접근할 수 있다는 착각속에서 실행되고 있다. 이런 일이 가능한 이유는 가상 메모리(Virtual Memory)의 존재 덕분이다. 가상 메모리의 존재는 커널이 프로세스들을 운영하는데 있어서 매우 큰 도움이 되는 메커니즘이다. 그럼 이제, 가상 메모리의 장점들을 알아보자.

* 보안성 증대
* 효과적인 자원 관리(메모리, 타임 슬라이스등)

#### 보안성
어떤 프로세스가 크래커(Cracker)에 의해서 해킹 당해서 모든 메모리 주소가 노출되고, 어떤 주소가 그 프로세스의 세그먼트의 시작이라는 등의 정보 또한 모두 노출되었다고 하자. 그렇다면 이 컴퓨터는 해킹의 위험에 노출된 것인가? 반드시 그렇다고 볼 수는 없다.  만약 물리 메모리와 가상 메모리가 1:1로 정확하게 같게 매칭된다면 그 크래커는 물리 메모리의 정보까지 손쉽게 알아낼 수 있을 것이다.  이는 커널의 해킹으로 이어지고, 그 크래커는 해당 컴퓨터를 장악할 수 있을 것이다.

하지만 현대 운영체제에서는 가상 메모리는 물리 메모리와 1:1(주소가 서로 일치하지 않음)로 매칭되지 않고, **페이지(Page)** 라고 하는 물리적인 단위로 쪼개져서 비선형적으로 매칭되어 있다. 따라서 크래커가 해당 컴퓨터를 완전히 해킹하기 위해서는 더 많은 절차가 필요하거나, 해당 프로세스의 성격에 따라서 불가능 할 수도 있다.

#### 효과적인 자원 관리
가상 메모리의 가장 큰 장점은 보안성이 크게 확보된다는 점이지만, 이는 효과적인 자원 관리로도 이어진다. 

1. 한 프로그램을 여러번 실행하여 여러개의 프로세스가 만들어 진다면 하나의 물리 메모리에 최소한의 페이지만 만들어 놓고 프로세스가 이를 공유하도록 매칭할 수 있다. 예) Code영역과 Data영역의 세그먼트를 구성하는 페이지들을 한번만 만들고, 한 프로그램에서 실행된 여러개의 프로세스가 이를 공유하도록 만듦.

2. 컴퓨터는 하드웨어의 특성상 한번에 가용할 수 있는 자원의 크기가 한정되어 있다. 그것이 메모리이건, 타임 슬라이스이건 간에.  게다가, 서로 1:1으로 매칭되지 않기 때문에 한 프로세스가 메모리를 독점하는 일이 없다. 따라서 컴퓨터의 모든 프로세스가 한번에 모든 자원을 요구하더라도 가상 메모리를 통해서 컴퓨터가 한번에 가용할 수 있는 자원을 필요한 만큼만 배정하고, 프로세스는 자신이 활용해야 하는 모든 자원을 사용할 수 있다고 생각하고 기능하기 때문에, 이는 곧 효율성으로 이어진다.

## 용어 정리 (Glossaries)

#### 프로세스
1. 추상적인 정의: 프로세스는 프로그램을 실행하기 위한 자원이 할당된, 커널이 정의한 추상적인 존재다.
2. 일반적인 정의: 실행중인 프로그램
3. 서로 다른 프로세스 끼리는 메모리(정확히 말하면 각자에게 할당된 가상 메모리)를 공유하지 않는다. 오직 IPC(Inter Process Communication)를 통해서만 Data를 교환할 수 있다.

#### 스레드
1. 추상적인 정의: 같은 가상 메모리와 광범위한 기타 속성을 공유하는 프로세스의 집합으로 상상할 수 있다.
2. 일반적인 정의: 프로세스 내에서 실행되는 여러 흐름의 단위 or 프로세스가 할당받은 자원을 이용하는 실행의 단위
3. 한 프로세스내에 있는 스레드는 각자의 Stack을 할당받아서 사용한다. 이는 스레드끼리 공유하는 데이터가 아니다. 단, 소속된 프로세스의 Code, Data, Heap영역은 공유한다.

#### 세그먼트
같은 성격을 지닌 데이터를 모아놓은 메모리 영역으로, 프로그램이 실행되는 과정에서 프로세스에 필요한 세그먼트를 할당한다. 세그먼트의 크기는 필요에 따라서 달라지기 때문에 가변적이라고 할 수 있다.

세그먼테이션(Segmentation)을 사용하는 가장 주된 이유는 메모리를 보호하기 위해서다.

우리가 흔히 만나는 세그멘테이션 폴트(Segmentation Fault)는 프로세스에 세그먼트를 할당 했을 때, 할당되지 않았거나 권한이 없는 영역에 읽기(Read), 쓰기(Write)등의 행위를 하면 일어난다.

#### 페이징

페이징 기법은 컴퓨터가 주기억장치(RAM)에서 사용하기 위해 보조기억장치(Hard Drive, SSD etc.)로부터 데이터를 저장하고 검색하는 메모리 관리 기법이다. 즉, 가상 메모리를 모두 같은 크기의 블록으로 편성하여 운용하는 기법이다. 이 때 일정한 크기를 가진 블록을 **페이지**라고 한다.

보통 페이지의 크기는 4096 바이트 (4 Kilobyte)로 512 바이트짜리 블록 8개를 모은것과 같다.

#### 블록

간단히 말해서, 블록은 기억공간을 나누는 단위다. 주로 커널이 블록 디바이스와 정보를 주고받을 때 사용하는 단위다. 따라서 커널과 블록 디바이스간의 공용어라고 할 수 있다.

보통 블록의 크기는 512 바이트다.

#### 힙

힙이 필요한 이유는, 다시 말해서 동적할당이 필요한 이유로 말할 수 있다. 

1. 첫째로, 메모리 공간을 효율적으로 사용하기 위해서 동적 할당을 사용한다. 그 차이는 프로그램을 작성할 때 메모리를 할당하느냐, 아니면 실행중에 필요한만큼 메모리를 할당하는 가의 차이다.

2. 왜 실행중에 메모리 할당이 필요할까? 그냥 정적 할당을 사용하면 되지 않을까? 그러나 메모리 필요량을 프로그램 작성시에 전혀 예측할 수 없는 경우가 있다.  이런 경우에는 실행중에 필요한 메모리양을 판단해서 필요한 만큼만 메모리를 할당해야 한다.

3.  그러면 크기가 가변적인 스택을 쓰면 되지 않는가? 왜 힙을 쓰는 건가? -> 스택의 크기는 상대적으로 작고, 만약 함수로 필요한 만큼의 데이터를 할당하면서 사용하면 함수는 해당 스택에 계속 머무르거나 할당한 메모리에 대한 포인터를 계속 가지면서 할당을 수행한 함수를 해제할 수가 없게 된다. 

4. 또한 추가적인 메모리가 필요하면, 그 메모리를 가지는 스택 프레임을 만들어야 하고, 그 메모리에 대한 포인터를 설정해야 한다. 이는 프로그래머가 관리해야하는 포인터의 수가 늘어나게 되는 결과로 이어진다. 

5. 그렇다면 해당 포인터에 걸려있는 메모리를 직접 증가/감소 시킨다면? -> 안될 일이다. 필요한 메모리가 할당되어 있는 스택을 **프로그램 실행시간**에  재조정 해야 하는데 이는 스택을 오염시키는 행위로, 번거로운게 문제가 아니라, 해서는 안되는 행동이다.

#### 가상 메모리(Virtual Memory)
가상 메모리는 RAM을 관리하는 방법의 하나로, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 말한다.

가상적으로 주어진 주소를 가상 주소(Virtual Address) 라고 하며, 실제 메모리 상에서 유효한 주소를 물리 주소(Physical address)라고 한다.

가상 주소 공간은 메모리 관리 장치(MMU)에 의해서 물리 주소로 변환된다. 이 덕분에 프로그래머는 가상 주소 공간상에서 프로그램이나 데이터가 물리 메모리 상에서 어떨게 존재하는지 의식할 필요가 없어진다. (알고 코딩해도 좋지만 처음부터 그렇게 하면 너무 머리가 복잡해져서 하기가 어렵다.)

#### 물리 메모리(물리 주소)
물리 주소는 메인 메모리를 접근할 때 사용하는 주소이며, 이 주소는 기억 장치의 주소 레지스터에 적재된다. 물리 주소 공간(Physical Address Space)은 물리 주소로써 접근 가능한 주소 공간이며 실제 메모리 공간과 같다.

