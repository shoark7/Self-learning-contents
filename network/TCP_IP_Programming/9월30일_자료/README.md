# TCP/IP 기본 개념과 예제

* 기본 개념은 다음 절을 참고하라.
* 예제는 여기 디렉토리 안에 있는 3가지 디렉토리를 살펴보자.

## 소켓 프로그래밍에서 알아야 할 기본

소켓 프로그램에 대해 알려면 컴퓨터 간 통신을 효과적으로 하기 위해 만들어진 계층별 프로토콜의 구조에 대해서 먼저 알아야 한다.  
구조 중 어느 계층의 자료를 제어하는가에 따라 프로그램의 구분이 달라진다. 결론부터 말하면 소켓 프로그램은 **전송 계층(Transport Layer)의 자료를 제어한다.**

### 소켓?

일반적인 클라이언트/서버 시나리오에서 응용 프로그램 간의 소켓 통신은 다음과 같다.  

* 각 응용 프로그램은 소켓을 생성한다. 소켓은 두 응용 프로그램 간의 통신에 필요한 '장치'와 같고, 응용 프로그램마다 소켓이 필요하다. 
* 서버는 자신의 소켓(정확히는 커널의 소켓에 **자신**을 결속하는 것) 을 이미 알려진 주소(이름)에 결속(bind)하여 클라이언트가 해당 주소를 사용할 수 있게 한다.  

소켓은 socket()이라는 시스템 호출로 생성한다. socket()은 그 이후의 호출에서 생성된 소켓을 가리킬 수 있도록 파일 디스크립터를 리턴한다.  

```{.c}
// protocol 부분은 0으로 지정하면 앞의 두 조합을 보고 커널에서 가장 적합한 프로토콜을 결정한다.
fd = socket(domain, type, protocol);
```

## 통신 도메인

소켓은 특정 통신 도메인(communication domain)에 소속되며, 통신 도메인은 다음과 같은 사항을 결정한다.  

* 소켓을 식별하는 방법(즉 소켓 '주소' 포맷, 예를 들어 sockaddr\_in)
* 통신 범위(즉 동일 호스트 내 응용 프로그램 간의 통신인지, 혹은 네트워크로 연결된 각기 다른 호스트의 응용 프로그램 간의 통신인지)

최근의 운영체제는 최소한 다음의 도메인을 지원한다.  

* 유닉스(AF\_UNIX) 도메인은 동일한 호스트 내 응용 프로그램 간의 통신을 지원한다. (POSIX.1g에서는 AF\_UNIX 대신 AF\_LOCAL을 사용했다. 그러나 SUSv3에서는 AF\_LOCAL이 사용되지 않는다.)
* IPv4(AF\_INET) 도메인은 인터넷 프로토콜 버전(IPv4) 네트워크로 연결된 호스트의 응용 프로그램 간의 통신을 지원한다.
* IPv6(AF\_INET6) 도메인은 인터넷 프로토콜 버전(IPv6) 네트워크로 연결된 호스트의 응용 프로그램 간의 통신을 지원한다. IPv6가 IPv4의 후속으로 설계됐지만, 아직까지는 IPv4가 더 광범위하게 사용된다.

### \_AF와 \_PF의 차이점

* 결론부터 말하자면 둘은 기능적으로 차이점이 없으므로 아무거나 사용하면 된다.

몇몇 코드에서는 AF\_UNIX 대신 PF\_UNIX 같은 상수가 사용된 경우를 볼 수 있다.  
이때 AF는 주소 패밀리(address family)를 의미하고 PF는 프로토콜 패밀리(protocol family)를 의미한다.  
초창기에서는 하나의 프로토콜 패밀리가 다양한 주소 패밀리를 지원할 것이라고 예상했지만,  
실제로는 다양한 주소 패밀리를 지원하는 프로토콜이 아직까지 정의되지 않았다.  
따라서 기존의 모든 구현에서는 PF\_로 시작하는 상수는 AF\_로 시작하는 상수와 동일하다고 간주할 수 있다.  
(SUSv3에서는 AF\_로 시작하는 상수만을 정의하며, PF\_로 시작하는 상수는 정의하지 않는다.)  

## 소켓 도메인의 특성표

| 도메인   | 통신 수단 | 응용 프로그램 간의 통신 | 주소 포맷                           | 주소 구조체  |
|----------|-----------|-------------------------|-------------------------------------|--------------|
| AF_UNIX  | 커널 내부 | 동일 호스트             | 경로명                              | sockaddr_un  |
| AF_INET  | IPv4 이용 | IPv4로 연결된 호스트    | 32비트 IPv4주소 +  16비트 포트 번호 | sockaddr_in  |
| AF_INET6 | IPv6 이용 | IPv6로 연결된 호스트    | 128비트 IPv6주소 + 16비트 포트 번호 | sockaddr_in6 |

## TCP/UDP 소켓의 차이점 정리

| 소켓 타입                   | TCP | UDP |
|-----------------------------|-----|-----|
| 연결 지향적인가?            | O   | X   |
| 메시지 경계가 보존되는가?   | X   | O   |
| 안정적인 송신이 보장되는가? | O   | X   |

## 소켓 시스템 콜

다음은 주요 소켓 시스템 콜 목록이다. 간략한 설명만 첨부했다.   

* socket() 시스템 콜은 새로운 소켓을 생성한다. 소켓을 식별하는 식별자 C언어의 int형이며, 프로세스의 파일 디스크립터 테이블에서 fd와 동일하게 취급된다.  

* bind() 시스템 콜은 해당 프로세스를 커널의 소켓 객체에 주소로 연결(결속bind)한다. 일반적으로 서버에서 bind()를 사용해 자신의 소켓을 기존에 알려진 주소로 결속시키고, 클라이언트는 해당 주소로 소켓을 연결할 수 있다.  

* listen() 시스템 콜은 **스트림 소켓**이 다른 소켓으로부터의 연결을 기다리게 한다. listen() 에 인자로 넘겨지고 성공적으로 그 임무를 수행하는 소켓을 랑데뷰 소켓이라고 한다. 
* 랑데뷰 소켓은 연결을 받아들였을 때, 자신이 연결을 직접 처리하지 않고, 새로운 소켓을 만들어 연결을 요청한 소켓에 맺어준다. 
* 이 때 새로운 소켓과 연결을 요청한 소켓을 커뮤니케이션 소켓이라고 한다.  

* accept() 시스템 콜은 상대편 응용 프로그램으로부터 연결을 기다리는 소켓으로의 연결 요청을 받아들이게 한다. 선택사항으로 피어(연결을 요청한 쪽) 소켓의 주소를 리턴할 수 있다.  

* connect() 시스템 콜은 다른 소켓과 연결을 맺는 데 사용된다. TCP 소켓을 사용한다면  클라이언트 측에서 주로 사용한다.

일반적으로 사용되는 read()와 write() 시스템 콜을 이용해 소켓 I/O를 수행할 수 있다.  
혹은 소켓 전용 시스템 콜(예: send(), recv(), sendto(), recvfrom())을 사용할 수도 있다.  
기본적으로 이 시스템 콜은 I/O작업이 끝날 때까지 대기한다.  


### 리눅스에서는 시스템 콜이 아니라 라이브러리 함수?

대부분의 리눅스 아키텍처(Alpha와 IA-64는 제외)에서 모든 소켓 시스템 콜은  
실제로는 socketcall()이라는 하나의 시스템 콜을 이용해 수행되는 라이브러리 함수다.  
(리는 리눅스 소켓이 초기에 독립된 프로젝트로 개발된 데서 발생한 산물이다.)  
그럼에도, 초기 BSD 및 당시 다른 유닉스 구현에서는 시스템 콜로 구현됐기 때문에  
여기너느 모든 함수를 시스템 콜이라고 부른다.  
























