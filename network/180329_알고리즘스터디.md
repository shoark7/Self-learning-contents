## 이진 탐색에서 발생하는 흔한 오류

예를 들어 C/C++/Java와 같은 언어로 다음과 같은 코드를 구현했다고 해보자.  

```
int binary_search(int* arr, int length, int value) {

	if (arr == nullptr || length < 0)
		return -1;

	int left = 0;
	int right = length - 1;
	int mid;

	while(left <= right) {
		mid = (left + right)/2;

		if(arr[mid] == value) {
			return mid;
		} else if (arr[mid < value]) {
			left = mid + 1;
		} else if (arr[mid] > value) {
			right = mid - 1;
		}
	}

	return -1;
}
```

여기서 mid = (left + right)/2; 라는 코드를 유심히 보도록 하자.   
(다른 문제들도 엄밀히 확인해보면 안될까? -> 여기서는 두 정수의 평균을 내는 완벽한 방법에 대해서만 탐구해보자.)  
int는 양수를 약 21억 5천만까지 표현할 수 있다.(2 ^ 31)  
따라서 그 이상을 넘어가게 되면 표현할 수 있는 범위를 넘어서기 때문에 오버플로우 에러가 발생한다.  
이에 대한 해결책을 몇 가지 제시해보겠다.   


* ``mid = left/2 + right/2;`` 나누기는 분배법칙이 성립한다.
* ``mid = (left + right) >> 1;`` 오버플로우가 일어났을 때 부호 비트를 다시 끌어와서 문제를 해결
* ``long mid;`` mid를 long으로 선언하면 표현범위가 크게 늘어나 현실적으로 문제가 해결된다. 그러나 완벽하지는 않다.  
* 해커의 기쁨(헨리 워렌)이라는 책을 보면 두 부호 없는(unsigned) 정수의 완벽한 바닥 함수(floor function)를 얻을 수 있다.  
  사실상 이 문제에 대한 완벽한 해결책이라고 할 수 있다. 코드는 다음과 같다.
  * ``(x & y) + ((x ^ y) >> 1);``



## 알고리즘을 정의하는 방법


1. 알고리즘의 정의를 읊는다. -> 나쁘진 않지만 실용적이지 않다.
2. 알고리즘을 입력과 출력으로 정의한다.


알고리즘을 만들 때는 하고자 하는 작업을 명확하게 명시해야 한다.  
왜 그럴까? 자연어로 이 알고리즘이 어떤 알고리즘인지 설명하는 것도 좋지만  
형식이 명확하게 정의되지 않아서 모호하게 표현될 수 있다.  
따라서 보다 정확한 표현을 위해 설계하려는 알고리즘이  
"무엇을(what)"을 하는지는 입력과(input)과 출력(output)에 의해 명시할 수 있다.  


예를 들어, 학생 100명의 수학시험 점수를 입력으로 받아, 오름차순으로 정렬한 리스트를 출력하는 알고리즘을 입력과 출력으로 표현해보자.  


* 입력 : 100개의 정수
* 출력 : 입력된 100개의 정수를 오름차순으로 정렬한 리스트



## 알고리즘의 여러가지 성질

알고리즘이 가져야 하는 주요 성질들을 알아보자.  


### 명확성
알고리즘의 각 단계는 명확해야 한다. 알고리즘이 명확하다는 것은 모호하지 않고 이해하기 쉽다는 것을 말한다.  
하지만 명확하다는 것을 장황한 것과 혼동하면 안된다.  
명확하게 표현한다고 지나친 세부사항을 구구절절히 기호적으로 기술하는 것은 오히려 알고리즘의 명확성을 떨어뜨린다.  

### 유한성
알고리즘은 단계들을 유한한 횟수로 거친 후 문제를 해결하고 종료해야 한다.  
무한루프, 기저사례가 없거나, 올바르지 않은 기저사례(도달할 수 없는 기저사례)를 정의하면 알고리즘이라고 할 수 없다.  

### 효율성
효율성은 모든 알고리즘이 반드시 가져야 할 특징은 아니지만...(링크 참고해서 작성할 것)  



## 정말 정말 중요한 4가지 점화식

```
// 팩토리얼(Factorial)
// 입력 : 0을 포함하는 자연수
int factorial(unsigned int n)
{
	return (n <= 1) ? 1 : n*factorial(n -1);
}

// 피보나치 수(Fibonacci number)
// 입력 : 0을 포함하는 자연수
int fibo(unsigned int n)
{
	return (n <= 1) ? n : fibo(n-1) + fibo(n-2);
}

// 조합(Combination - binomial coefficient)
// 입력 : n과 r은 0을 포함하는 자연수 단,(r <= n)
int binom(int n, int r)
{
	if(n == r || r == 0) return 1;
	return binom(n-1, r-1) + binom(n-1, r);
}


// 유클리드 호제법(Euclidean algorithm)
// b와 s는 0을 포함하는 자연수
// b는 big, s는 small 따라서 b > s이다.
int gcd(int b, int s)
{
	return (s == 0) ? b : gcd(s, b%s);
}
```

다음 시간까지 외워오기!



## 점근 표기법

점근 표기법은 시간 복잡도를 표현하는 좋은 방법이다.  
엄밀한 수학적 정의보다는 여러가지 와닿는 예시들을 하나씩 공부해보자.  


### 여러가지 시간 복잡도

* O(1): 단순 계산(a + b와 같은 연산, 배열에 접근하는 연산, 수열의 합을 구하는 일반항, fibo를 구하는 일반항 등등)
* O(logN): N개를 절반으로 계속해서 나눔(분할 정복법)
* O(N):1중 for문(선형(linear)적)
* O(NlogN): 비교기반 정렬에서 나올 수 있는 가장 좋은 시간 복잡도. 병합 정렬이나 퀵소트의 일반적인 상황에서 만날 수 있다.   
* O(N^2): 2중 for문
* O(N^3): 3중 for문
* O(2^N): 크기가 N인 집합의 부분집합, 길이가 N인 비트열이 표현할 수 있는 상태의 개수
* O(N!): 크기가 N인 순열


### 점근 표기법과 극한

고등학교 때 배운 극한의 내용을 정리하여 점근 표기법과 비교해보면 점근 표기법의 특징을 쉽게 파악할 수 있다.   
다음 표를 보자.

|                       | 함수의 극한                      | 점근 표기법   |
|-----------------------|----------------------------------|---------------|
| 차수(degree)          | 중요                             | 중요          |
| 계수(coefficient)     | 중요                             | 무시 |
| 상수항(constant term) | 경우에 따라 다르지만 대체로 무시 | 무시          |
| 변수들(variables) | 극한으로 표현하지 않으면 상수항 취급 | 일단 입력으로 들어온 변수들의 종류(예를 들어 V와 E)가 다르면 무시하지 않는다. |



## 다이나믹 프로그래밍의 정의, 그리고 다이나믹 프로그래밍을 푸는 여러 팁들


* 사실 다이나믹 프로그래밍은 그 뜻이 전혀 와닿지 않게 작명되었다.
* "기억하며 풀기"가 더 알맞은 이름이지만, 이미 DP라는 이름이 고정되었다.
* DP로 어떤 문제를 풀려면 다음 2가지 특징을 만족해야 한다.
  1. Overlapping Subproblem(겹치는 부분문제) :
    * 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.
    * 문제를 작은 문제로 쪼갤 수 있다.
  2. Optimal Substructure(최적 부분구조) : 
    * 최적 부분구조를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.


### DP 문제인가? 아닌가?

* ~의 최소값(min), 최대값(max), 모든 경우의 수를 구하라는 문제가 나온다면 DP를 의심해볼 수 있다.
* 여기에 더해, 문제를 점화식으로 표현(추상화)할 수 있다면 DP가 거의 확실하다.



## 오늘 풀어본 문제들


* 단순재귀로 피보나치 수 구하기
	- [2747번 문제](https://www.acmicpc.net/problem/2747)
* DP로 피보나치 수 구하기
	- [2748번 문제](https://www.acmicpc.net/problem/2748)
* 단순재귀로 이항계수 구하기
	- [11050번 문제](https://www.acmicpc.net/problem/11050)
* DP로 이항계수 구하기 <- 오늘 제일 좋았던 문제! dt를 구현하는, 인덱싱이 되는 자료구조를 2차원으로 잡아야 한다는 점에서 배울점이 있었다.
	- [11051번 문제](https://www.acmicpc.net/problem/11051)



## 문자열과 계산이론(TOC)

* 브루트 포스 문자열 매칭 알고리즘 - [나무위키 - 문자열 알고리즘](https://namu.wiki/w/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
* 계산이론의 가장 기본적인 내용들 - [계산이론의 아주 기본적인 내용](https://github.com/haidn1994/TIL/blob/master/theoryOfComputation/notationalConvention_%ED%91%9C%EA%B8%B0%EA%B4%80%EB%A1%80.md)

* 왜 계산이론을 공부해야 하는가? -> 기호(symbol), 문자열(String), 언어(Language)등을 보다 공학적인, 형식적인 관점으로 바라보아야 현실의 문제를 푸는데 유용한 영감을 얻을 수 있다.



## 재밌는 파이썬

* 파이썬은 기본적인 4가지 자료형이 있는데, 이들은 모두 고유한 부모 자료형 클래스를 상속받고 있고,  
  그 목록은 collections.abc 모듈에서 확인할 수 있다.
* 각 언어의 철학이나 주된 쓰임새에 따라 같은 이름을 가진 메소드의 동작에 차이가 있다.
	* 예를 들어, R의 경우에는 배열과 배열의 '+'연산이 원소간 더하기 연산으로 처리된다.
	* 반면에 파이썬의 경우에, 두 배열이 접합(Concatenation)된다.



## 재밌는 쉘 스크립트


* ``{ls bin1; ls /usr/bin;} | wc -l``
	* {}는 그룹핑 하는 연산자다. 따라서 이 연산자로 묶으면 출력을 한데 묶을 수 있다.
	* 그리고 나서 wc -l을 하면 한데 묶인 출력을 연산하기 때문에 변거롭게 변수를 쓸 필요가 없어진다.
