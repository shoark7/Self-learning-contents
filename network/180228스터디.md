## World Wide Web(WWW)

WWW는 인터넷 **메시징** 애플리케이션 계열 중 하나다.  
WWW는 가장 중요한 세가지 요소(HTML, URI, HTTP)를 비롯한 수많은 관련 구성 요소를 포함하는 완전한 시스템이다.
* 메시지란 프로세스간에 통신되는 구조화된 데이터를 말한다.
* 따라서 메시지의 반대말은 스트림(구조화되지 않은 일련의 데이터)를 말한다.
* 웹이 킬러 애플리케이션이 될 수 있었던 이유는 기존 FTP나 유즈넷 등이 문서간 연결성이  
  떨어져서 사용자가 브라우즈하기 어려웠기 때문이다.
* 반면, WWW는 하이퍼텍스트(하이퍼링크: 한 문서에서 또 다른 문서로의 연결을 지원하는 기능을 강조한 단어)의  
  도입으로 문서간 연결성을 극대화했다.
* 웹과 다른 메시지 전송 시스템을 차별화하는 주요 개념은 바로 **하이퍼텍스트**다.
* 하이퍼링크는 웹 문서와 자원에 주소를 지정했다는 중요한 개념을 내포하고 있다.
* 하지만 모든 하이퍼텍스트가 끝없이 연결되어 있고, 끝없이 순환한다는 것은 맞지 않다.   
  왜냐하면 다른 웹 문서로 가는 하이퍼링크를 가지고 있지 않는 웹 문서가 존재하기 때문이다.
* `Mark up`이라는 용어의 뜻은 "구조화한다(의미를 부여한다.)"다.

<br>

## HTTP(Hypertext Transfer Protorol)

* HTTP 0.9: 초기에 간단한 텍스트 교환만을 위해 만들어진 프로토콜로 RFC(Request for protocol) 자체가 없다.
* HTTP 1.0: MIME(Multipurpose Internet Mail Extension)을 차용하고, 텍스트뿐만 아니라,  
	    다양한 미디어를 취급할 수 있도록 프로토콜을 일반화했다.
* HTTP 1.1: 1.0의 여러 성능 이슈를 극복하기 위한 기능들이 많이 추가되었다.
	* 다중 호스트 네임의 지원
	* 지속적 연결(Persistent Connection)
	* 부분적인 자원 선택
	* 더 좋은 캐싱과 프록싱 자원
	* 컨텐트 협상
	* 향상된 보안


### 중개자 HTTP와 요청/응답 사슬

HTTP 메시지의 교환에 관여하는 클라이언트, 하나 이상의 중개자, 서버의 전체집합을  
통틀어 **요청-응답 사슬(request-response chain)이라고 한다.   **
여기서 중개자(Intermediary)란 프록시(Proxy: 대리자/대리인), 게이트웨이(Gateway), 터널(Tunnel) 등을 의미한다.  

> 주의: 중개자는 클라이언트와 서버 사이에 위치에 존재하는데, **메시지의 성질을 바꾸기도 한다.**

<br>


## HTTP 일시적 연결, 지속적 연결, 파이프라이닝

### 지속적 연결

지속적 연결과 일시적 연결의 주요 차이점은 TCP 연결을 각 요청/응답 과정 후에도 닫지 않고 그대로 유지하는 것이다.  
그리고 지속적 연결은 HTTP 1.1에서부터 지원한다.


### HTTP에서는 데이터의 길이를 지정하는 데 각별한 신경을 쓰고 있다.

왜냐하면 TCP는 스트림 기반 프로토콜이라서 전송하는 파일들을 구분하지 않는다.  
참고로 TCP는 데이터를 받을 때(데이터를 스트림으로 받는다.)나,  
보낼 때(데이터 구조를 신경쓰지 않고 그냥 세그먼트로 만든다.)나 데이터 구조를 신경쓰지 않는다.  
그래서 지속적 연결의 단점은 파일 전송이 상대적으로 복잡해졌다는 것이다.  

<br>


## HTTP 일반 메시지 형식

* HTTP의 메시지 형식은 각 줄이 CRLF로 구분된다.
	* 여기서 CRLF는 CR(Carriage Return)이 커서를 앞으로 당기는 타자기의 동작에서 유래한 개념이고,
	* LF(Line Feed)는 줄을 한 칸 내렸던 타자기의 동작에서 유래한 개념이다.
* 헤더는 반드시 평문(plaintext)으로 전송되고, 본문(body)은 전송하는 데이터에 따라 다르다.
* Connection: Close에서 알 수 있는 여러 뜻을 알아야 한다.
	* 일시적 연결을 행하라.
	* 클라이언트가 HTTP 1.1을 지원한다는 사실을 알 수 있다.
* 요청 URI에서 호스트를 제외한 URL만 있을 경우, 서버로의 직접 전송이고 전체 URL경로가 명시되면, 프록시 서버 전송이다.


### HTTP 헤더 종류

* HTTP 헤더에는 크게 4가지 종류가 있다.
	* 일반 헤더(generic header): 메시지 내용보다는 메시지 자체에 대한 정보를 가지고 있다.(즉, 메타 데이터)
	* 요청 헤더(request header): 요청 매시지에서만 존재하며, 클라이언트 요청의 특성에 대한 자세한 내용을 서버에 알려준다.
	* 응답 헤더(response header): 상태 줄(status line)에 대한 부가 정보를 제공한다.
	* 실체 헤더(entity header): 응답하는 실체(본문에 들어가는 요청자가 요청한 파일 등)에 대한 정보를 포함한다.
		* 참고: 실체가 없음에도 실체 헤더가 존재하는 경우는 HEAD 메소드의 응답일 경우다.

<br>


## HTTP 메소드

* PUT과 GET은 정확하게 반대다.
	* GET은 서버에서 클라이언트로 데이터를 복사한다.
	* PUT은 클라이언트에서 서버로 데이터를 복사한다.
* POST에서 URI는 요청에 포함된 실체를 처리하는 프로그램을 나타낸다.


### 안전한 메소드들

* GET
* HEAD
* OPTION
* TRACE


### 멱등한(다음 수식을 만족하면 멱등: f(x) = f(f(x)))  메소드들

* POST를 제외한 모든 HTTP 메소드들은 멱등하다.

## HTTP의 상태 코드(status code)의 형식

| 상태 모드 형식 | 의미             | 설명                                                                                                     |
|----------------|------------------|----------------------------------------------------------------------------------------------------------|
| 1yy            | 정보 제공 메시지 | 일반적인 정보를 제공한다. 요청의 성공이나 실패를 표시하지는 않는다.                                      |
| 2yy            | 성공             | 서버가 메소드를 받았고 해석했으며 정상적으로 수행했다.                                                   |
| 3yy            | 리다이렉션       | 요청이 완전하게 실패한것은 아니다. 다만 성공적으로 작업을 마치기 전에 추가적인 행동이 필요함을 나타낸다. |
| 4yy            | 클라이언트 에러  | 요청이 잘못되었거나, 구문 오류가 발생했거나, 기타 클라이언트의 오류가 발생해 요청 수행을 완료할 수 없다. |
| 5yy            | 서버 에러        | 요청은 유효하다. 그러나 서버 자체의 문제로 인해 그 요청을 처리할 수 없다.                                |

<br>


## HTTP 헤더

* 일반 헤더
	* Transfer-Encoding과 Content-Encoding의 차이점
		* Transfer-Encoding: 장비 간 데이터의 안전한 전송을 보장하는 목적을 위해서만 이 인코딩을 사용한다.
		* 각 홉별(hop-by-hop)로 적용되며, 일반 헤더로서 메시지 전체의 적용되는 인코딩을 표시한다.
	* Content-Encoding: HTTP 메시지 내 실체를 전송 전에 포장하는 데 쓰인다.
		* 컨텐트 인코딩은 종단 간(end-to-end)에 적용되며, 실체 헤더로서 실체에 적용되는 인코딩을 표시한다.
* 요청 헤더
	* Accept\*: Accept\*이 들어가는 HTTP 메시지는 요청 메시지라는 것을 알 수 있다.
	* From\*: From\*이 들어가는 HTTP 메시지는 요청 메시지라는 것을 알 수 있다.
* 응답 헤더
* 실체 헤더

<br>

## HTTP 실체, 전송, 코딩 메소드, 컨텐트 관리

### email과 MIME과 HTTP의 MIME의 차이점

* email은 전체 내용이 base64 인코딩을 적용해서 전송되는 데 반해, HTTP는 다른 변환 기법을 적용하지 않는다.
* 왜냐하면 base64 인코딩을 사용하면 데이터 크기가 33% 증가하기 때문이다. 
* 이것이 HTTP 개발자가 프로토콜을 완전히 MIME을 따르지 않도록 결정하게 만든 이유 중 하나다.


### 컨텐트 협상 기법

HTTP 1.1 표준은 이 협상을 수행하는 기본적인 두 가지 방법을 정의한다.  

* 서버 주도(Server-Driven) 협상
* 에이전트 주도(Agent-Driven) 협상

### 선호도 비중을 위한 품질값

* 우선 다음 링크를 참고하자. => [MDN - Quality Value](https://developer.mozilla.org/en-US/docs/Glossary/Quality_values)
* 책에 있는 예문은 번역이 잘못되었거나, 예문이 잘못되었거나 또는 둘 다 잘못되어서 헷갈리는 듯 하다. 주의해서 읽도록 하자.


## HTTP의 기능, 능력, 문제

* HTTP 캐싱 기능
	* HTTP에서 성능을 끌어올리는 가장 중요한 도구로 HTTP 1.1에서 본격적으로 지원하기 시작했다.
* 캐시의 위치는 근접성과 보편성을 교려해서 결정해야 한다. 정보가 요청자에게 가까울수록(논리적) 캐시 히트가 많아 진다.
* 반대로 정보가 소스에 가까울수록, 더 많은 사용자가 이득을 본다.
* 중개자(intermediary)의 캐시는 shared cache, 또는 public cache라고도 한다.
* 프록시와 캐시의 차이점
	* 프록시는 HTTP 요청-응답 사슬 안에 중개자로 별도의 구성요소(component)로 존재한다.
	* 캐시는 클라이언트, 서버 등을 포함한 사슬 내 모든 장비가 가질 수 있다.


### 쿠키(cookie)

HTTP는 기본적으로 stateless한 프로토콜이기 때문에 로그인 후 서비스 이용할 때와 같은 상황에서 큰 문제가 발생할 수 있다.  
따라서 서비는 응답할 때 쿠키라는 작은 데이터를 클라이언트에게 전송하고,  
클라이언트는 다른 요청과 쿠키를 같이 보냄으로써 상태를 유지하는 방법을 쓰고 있다.  
쿠키는 민감한 정보를 보내거나, 바람직하게 사용되지 않음으로써 프라이버시, 보안이슈를 야기하는 문제가 있다.  



---

## 번외

### 텍스트 파일의 테이블 확장

* 텍스트 파일을 아스키 문자로만 만들면 파일 타입은 아스키 텍스트 파일로 결정된다.
* 하지만 그 파일에 한글의 UTF-8 문자를 넣으면, 그 파일은 UTF-8로 확장된다.  


### Shell과 true와 false 프로그램

* UNIX 계열 쉘에는 true와 false라는 프로그램이 있는데 이 프로그램들은 쉘 프로그래밍에서 유용하게 쓰인다.
	* true는 프로그램의 정상 종료 코드(0)을 반환하고,
	* false는 프로그램의 비정상 종료 코드중 하나인 (1)을 출력한다.
	* 프로그램의 종료코드는 0 - 255까지 총 256가지가 있다.

```
# TIP

echo $? # 최근에 실행한 프로그램의 종료코드를 출력한다.
```

### General과 Generic의 차이점

* General은 '일반적인'이라는 의미와 가까운데 그것은 '특수한 것'의 존재를 암시한다.
* Generic은 반면 프로그래밍적으로는 '포괄하는'이라는 의미로서 여러 타입을 묶는 일반 타입을 정의한다.  
  여기에 타입을 매개변수로 지정함으로써 구체적인 타입이 정의된다.  


## 다음 시간까지(03/08)

* '1%의 네트워크 원리' 2단원 끝까지 학습해올 것
* 성환님: 네트워크 수업시간에 풀었던 문제(파일) 준비하기
