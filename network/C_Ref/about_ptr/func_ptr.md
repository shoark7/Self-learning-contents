#함수 포인터의 이해
변수만 메모리 공간에 저장되는 것이 아니다.  
프로그램 실행의 흐름을 구성하는 함수들도 바이너리 형태로 메모리 공간에 저장되어서 호출 시 실행된다.  
그리고 이렇게 메모리 상에 저장된 함수의 주소 값을 저장하는 포인터 변수가 바로 *함수 포인터 변수*이다.  


프로그래머가 정의하는 모든 함수는 프로그램 실행 시 '메인 메모리'에 저장되어서 실행이 된다.  
그리고 함수의 이름은 메모리상에 저장된 함수의 주소 값을 의미한다.  
**배열의 이름이 배열의 시작 주소 값을 의미하듯, 함수의 이름도 함수가 저장된 메모리 공간의 주소값을 의미하는 것이다.**  


물론 배열의 이름과 마찬가지로 함수의 이름도 그 형태가 상수다.(즉, 주소 변경 불가능)  
그런데 이러한 함수의 주소 값 저장을 위한 포인터 변수를 별도로 선언할 수 있으며,  
이러한 용도로 선언된 포인터 변수를 가리켜 *'함수 포인터 변수'*라 한다.  


##함수 포인터의 형(type)
포인터를 사용하려면 먼저 포인터를 선언해줘야 하는데, 함수 포인터는 어떻게 선언해야 할까?  
차근차근 생각해보자, 함수의 이름이 함수의 시작 주소가 된다고 앞서 말했다. 그렇다면 함수 포인터 변수에는 함수의 이름이 들어갈 수 있다.  
하지만 값을 대입하고 사용하기 전에 생각해보면, 어떤 변수이건 형(type)을 결정해줘야 올바르게 선언하고 사용할 수 있다.  
그렇다면 함수 포인터는 형(type)을 어떻게 구별할까? 사실은 간단하다.  


* 함수이름의 포인터 형은 **반환형**과 **매개변수의 선언형태**를 통해서 결정짓도록 약속되어 있다.


예를 들어 다음과 같은 함수의 포인터 형(type)은
```{.c}
int simple_func(int num)
{
	//...
}
```
반환형이 int이고 매개변수로 int형 변수가 하나 선언된 포인터 형(type)이다.  


##적절한 함수 포인터의 선언
이제 함수의 주소 값(함수 포인터의 값)을 저장할 수 있는 포인터 변수는 어떻게 선언해야 할까?  
이 포인터 변수에는 반환형 정보와 매개변수 선언의 정보가 모두 표현되어 있어야 한다.  
따라서 다음과 같이 의미를 부여하여 함수 포인터 변수를 선언하기로 약속되어 있다.  
```{.c}
int (*fptr)(int) // 중간 -> fptr은 포인터다.(괄호를 충실하게 쳐서 구분이 쉽게 하면 좋다.)  
int (*fptr)(int) // 왼쪽 -> 반환형이 int인 함수 포인터  
int (*fptr)(int) // 오른쪽 -> 매개변수 선언이 int하나인 함수 포인터  
```
단, 주의해야 할 점이 하나 있는데, 포인터 선언시 \*는 선언형과 이름 사이 어디에 있어도 상관 없기 때문에,  
함수 포인터를 선언할 때는 반드시 \*와 함수 포인터 변수의 이름을 한 괄호에 묶어야 한다.  
안 그러면 다음과 컴파일러가 다음과 같이 간주한다.  
```{.c}
int *fptr(int) // int형 매개변수를 받아 int형 포인터를 반환하는 함수 fptr
int (*fptr)(int) // int형 매개변수를 받고 int를 반환하는 함수 형(type)함수 포인터 변수 fptr
```
꼭 괄호를 빼먹지 말고 잘 닫아서 컴파일러가 잘못 해석하는 일을 막자!  



이제 간단한 용례를 하나 들어보겠다. 예를 들어 다음과 같은 함수가 있다고 하자.  

```{ .c}
int SoSimple(int num1, int num2)
{
	//...
}
```
이 함수는 반환형이 int형이고 매개변수로 int형 변수가 두 개 선언되었으니,  
이 함수의 주소 값 저장을 위한 함수 포인터 변수는 다음과 같이 선언하면 된다.  
```{ .c}
int (*fptr)(int, int);
```
그리고 이 함수 포인터 변수에 함수 SoSimple의 주소 값을 저장하려면 다음과 같이 대입연산을 진행하면 된다.  
```{ .c}
fptr=SoSimple;
```
이렇듯 대입 연산이 끝나고 나면 fptr과 SoSimple에는 동일한 값이 저장되어, 상수냐 변수냐가 이 둘의 유일한 차이점이 된다.  
(물론 값에 있어서 차이가 없다는 것이지 둘이 실행될때는 여러가지 복잡한 과정을 거치게 되고 실행되기까지의 과정도 큰 차이가 날 수 있다.)  
따라서 fptr을 이용해서도 다음과 같이 SoSimple함수를 호출할 수 있다.  
```{ .c}
fptr(3, 4)	// SoSimple(3, 4)와 동일한 결과를 보인다.  
```
이제 유용하게 사용할 수 있는 예제를 하나 보여주겠다.
```{.c}
#include <stdio.h>

int WhoIsFirst(int age1, int age2, int (*cmp)(int, int))
{
	return cmp(age1, age2);
}

int OlderFirst(int age1, int age2)
{
	return (age1 > age2) ? age1 :
	       (age1 < age2) ? age2 : 0;
}

int YoungerFirst(int age1, int age2)
{
	return (age1 < age2) ? age1 :
	       (age1 > age2) ? age2 : 0;
}

int main(void)
{
	int age1 = 20;
	int age2 = 30;
	int first;

	printf("장유유서 \n")
	first = WhoisFirst(age1, age2, OlderFirst);
	printf("%d세와 %d세 중 %d세가 먼저 입장! \n\n", age1, age2, first);

	printf("왜 애를 기를 죽이고 그래요?\n")
	first = WhoisFirst(age1, age2, YoungerFirst);
	printf("%d세와 %d세 중 %d세가 먼저 입장! \n\n", age1, age2, first);

	return 0;
}
```
다음은 하나씩 좀 더 자세하게 알아보도록 하겠다.  

##함수 포인터 사용하기(주의점)
여기서는 함수 포인터를 사용할 때 주의점에 대해서 알아본다.


컴파일러는 함수 이름 앞에 주소 연산자가 사용되면 적절하게 무시한다.  
```{.c}
fptr = &square;
```
함수 이름은 그 자체로 주소를 반환하며, 주소 연산자는 불필요하다.  


함수 내부에 선언된 함수 포인터 변수는 당연하게도 스택에 할당된다.
함수 바깥에 선언되어 있다면 bss영역이나 초기화된 데이터 세그먼트에 할당될 것이다.  
만약 상수로 선언되어 있다면 데이터 세그먼트에 할당될 것이다.  
함수 포인터 변수도 평범한 포인터 변수이다.  


함수는 어디에 있을까? -> 코드(텍스트)영역에 있고 대부분의 상황에서 쓰기는 불가능하다.  

##함수 포인터 전달하기
함수 포인터는 대체로 그 복잡한 선언때문에, typedef로 가려서 사용하는 경우가 많다.  
하지만 꼭 그런것은 아니고, 오히려 명확성을 위해서 typedef로 가리지 않고 인자로 넘기거나 반환하는 경우도 많다.  


다음은 typedef를 사용하지 않는 예다.
```{.c}
int add(int num1, int num2){
	return num1 + num2;
}

int sub(int num1, int num2){
	return num1 - num2;
}

int compute(int (*oper)(int, int), int num1, int num2){
	return oper(num1, num2);
}
```


다음은 typedef를 사용하는 예다.
```{.c}
int add(int num1, int num2){
	return num1 + num2;
}

int sub(int num1, int num2){
	return num1 - num2;
}

typedef int (*fptrOperation oper)(int, int)

int compute(fptrOperation oper, int num1, int num2){
	return oper(num1, num2);
}
```
그리고 다음 코드로 위 함수를 테스트 할 수 있다.

```{.c}
#include <stdio.h>

int main(void)
{
	printf("add:%d \n", compute(add, 5, 6));
	printf("sub:%d \n", compute(sub, 5, 6));

	return 0;
}
```
##함수 포인터 반환하기
이 디렉토리의 useful_func_ptr.c와 complex_ptr.md를 참고하라.  

##함수 포인터의 배열 이용하기

특히 객체 지향 프로그래밍을 언어 차원에서 적극적으로 지원하는 언어들은  
이런 가상 함수의 사용이 매우 빈번하게 발생하는데, 이는 클래스가 함수 포인터 배열을 가지고 사용하는 형태로 구현되어 있다.  
또한 해당 언어에서는 **가상 함수**라는 명칭이 빈번하게 사용되는데 각종 컴퓨터 하드웨어 관련 서적을 참고하면 좋을 것이다.  

##함수 포인터 비교하기

##함수 포인터 캐스팅

##함수 포인터의 성능
함수 포인터는 어떠한 조건 문장을 사용하지 않고서 컴파일 시간에 미리 결정된 순서가 아닌  
함수의 실행을 제어하는 방법을 제공한다. 하지만 그만큼 대가를 치룰 가능성이 높기도 하다.  


함수 포인터 사용에 한 가지 우려되는 점은 잠재적으로 프로그램이 느리게 동작한다는 것이다.  
함수 포인터를 사용하면 프로세서는 파이프라이닝(Pipelining)과 분기 예측(branch prediction)을  
함께 사용하지 못할 수도 있다. 분기 예측은 프로세서가 명령의 실행 순서를 예측하고 실행하는 기술이다.  
파이프라이닝은 프로세서의 성능을 향상하기 위해 일반적으로 사용되는 하드웨어 기술이며 명령을 중첩 실행한다.  
이 구조에서는 프로세서는 다음에 실행될 것으로 판단되는 분기 처리를 시작하게 되며,  
프로세서가 성공적으로 정확한 분기를 예측한다면 현재 파이프라인에 있는 명령을 폐기할 필요가 없어져 성능이 향상된다.  
하지만 함수 포인터는 컴파일 시간의 분석을 어렵게 하거나 못하게 하기 때문에 프로세스의 성능이 낮아질 수도 있다.  


하지만 측정하기 전에는 아무도 모른다. **대체로** 느려질 수 있다고 짐작할 수는 있지만...  
프로그램의 속도 저하는 발생할 수도 있고, 발생하지 않을 수도 있다.  



