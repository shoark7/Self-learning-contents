#복잡한 포인터 

##복잡한 포인터 선언의 여러가지 예시

C를 공부하고 사용하다 보면 이해하기 어려운 포인터 선언이 등장하는데, 
여기에 대해서 짚고 넘어가보는 시간을 가져본다.  


다음은 포인터의 선언과 그 포인터의 의미이다.  
결합 순서를 자세히 보기 바란다.  


|               | 선언              | 의미                                                                                                                                  |
|---------------|-------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| 단순 포인터   | int \*np           | 포인터 변수:  int형의 주소를 저장한다.                                                                                                |
| 단순 포인터   | int \*\*np          | 포인터 변수:  int형 주소를 저장하는 포인터 변수의 주소를 저장한다.                                                                    |
| 단순 배열     | int arr\[3\]        | 배열: 1차원 배열로, int형 값들을 저장한다.                                                                                            |
| 단순 배열     | int arr\[2\]\[3\]     | 배열: 2차원 배열로, int형 값들을 저장한다.                                                                                            |
| 배열과 포인터 | int \*arr\[3\]       | 배열: int형 주소를 저장하는 포인터 변수를 저장할 수 있는 배열이다.                                                                    |
| 배열과 포인터 | int (\*arr)\[3\]     | 포인터 변수: int형 2차원 배열의 주소를 저장한다. -> 크기가 3인 배열을 한 묶음으로 봐서 각 배열의 시작주소를 담는 포인터 변수          |
| 배열과 포인터 | int (\*arr)\[2\]\[3\]  | 포인터 변수: int형 3차원 배열의 주소를 저장한다. -> 크기가 2\*3인 배열을 한 묶음으로 봐서 각 배열의 시작주소를 담는 포인터 변수        |
| 배열과 포인터 | int (\*arr\[2\])\[3\]  | 배열: 2차원 배열들의 주소를 저장한다. ->크기가 3인 배열을 한 묶음으로 보는 포인터 변수를 저장하는 배열을 선언한다. 이 배열의 크기는 2 |
| 배열과 포인터 | int \*(\*arr)\[3\]    | 포인터 변수: int형 주소를 저장하는 2차원 배열의 주소를 저장하는 포인터 변수 -> 주의: int를 저장하는 것이 아닌 \*int를 저장             |
| 함수와 포인터 | int \*func();      | 함수의 원형: int형 주소를 반환하고 인자 없는 함수 원형                                                                                |
| 함수와 포인터 | int (\*func)();    | 함수 포인터: int형을 반환하고 인자가 없는 함수들의 주소를 저장하는 포인터 변수                                                        |
| 함수와 포인터 | int (\*func\[2\])(); | 함수 포인터: int형을 반환하고 인자가 없는 함수들의 주소를 저장하는 포인터 변수의 배열 -> 크기는 2                                     |


이제 각각의 예를 하나씩 들어볼 차례이다.  

* 1번
```{.c}
#include <stdio.h>

void main()
{
	int n = 10;
	int *np;

	np = &n;

	printf("n:%d *np:%d\n", n, *np);
}
```
np는 int형 포인터 변수로 32비트 운영체제면 4바이트, 64비트 운영체제이면 8바이트를 차지한다.  
또한 int형 주소를 저장한다. 이 문서에서는 64비트 운영체제를 기준으로 잡겠다.  

* 2번
```{.c}
#include <stdio.h>

void main()
{
	int n = 10;
	int *np;
	int **npp;
	
	np = &n;
	npp = &np;

	printf("n:%d *np:%d **npp:%d\n", n, *np, **np);
}

```
npp는 2차원 포인터 변수로, 8바이트이고 1차원 포인터 변수의 주소를 저장한다.  

* 3번
```{.c}
#include <stdio.h>

void main()
{
	int arr[3] = {10, 20, 30};

	printf("[0]:%d [1]:%d [2]:%d", arr[0], arr[1], arr[2]);
}

```
int arr[3]은 int형 배열로, int형 메모리 3개를 갖는 24바이트 메모리이다.

* 4번
```{.c}
#include <stdio.h>

void main()
{
	int arr[2][3] = {{10, 20, 30}, {100, 200, 300}};


	printf("[0]-> [0]:%d [1]:%d [2]:%d\n", arr[0][0], arr[0][1], arr[0][2]);
	printf("[1]-> [0]:%d [1]:%d [2]:%d\n", arr[1][0], arr[1][1], arr[1][2]);
}
int arr[2][3]은 int형 2차원 배열로, int형 6개를 갖는 48바이트 메모리이다.  

```
* 5번
```{.c}
#include <stdio.h>

void main()
{
	int n1 = 10;
	int n2 = 20;
	int n3 = 30;
	int *arr[3] = {&n1, &n2, &n3};

	printf("n1:%d n2:%d n3:%d\n", n1, n2, n3);
	printf("arr[0]:%p arr[1]:%p arr[2]:%p\n", arr[0], arr[1], arr[2]);
	printf("*arr[0]:%d *arr[1]:%d *arr[2]:%d\n", *arr[0], *arr[1], *arr[2]);
}
int *arr[3]는 int형 주소를 3개까지 저장하는 배열로,  
각 배열 요소(arr[0], arr[1], arr[2])가 int형 주소를 저장한다. 총 24바이트다.  

```

* 6번
```{.c}
#include <stdio.h>

void main()
{
	int arr2[2][3] = {{10, 20, 30}, {100, 200, 300}};
	int (*arr)[3];

	arr = arr2;

	// 이 코드를 확실하게 이해하려면 배열 연산자"[]"를 확실하게 이해해야 한다.
	printf("[0]-> [0]:%d [1]:%d [2]:%d\n", arr[0][0], arr[0][1], arr[0][2]);
	printf("[1]-> [0]:%d [1]:%d [2]:%d\n", arr[1][0], arr[1][1], arr[1][2]);
}
```
arr은 포인터 변수로, 4바이트이며 2차원 배열과 같은 열의 개수가 [3]인 int형 배열의 시작주소를 저장하기 위해 사용된다.  
포인터 변수이므로 8바이트이다.  

* 7번
```{.c}
#include <stdio.h>

void main()
{
	int arr3[2][2][3] = 
	{ {{10, 20, 30},{40, 50, 60}},
	  {{70, 80, 90},{100, 110, 120}} };

	int (*arr)[2][3];

	arr = arr3;

	printf("[0][0]-> [0]:%d [1]:%d [2]:%d\n", arr[0][0][0], arr[0][0][1], arr[0][0][2]);
	printf("[0][1]-> [0]:%d [1]:%d [2]:%d\n", arr[0][1][0], arr[0][1][1], arr[0][1][2]);
	printf("[1][0]-> [0]:%d [1]:%d [2]:%d\n", arr[1][0][0], arr[1][0][1], arr[1][1][2]);
	printf("[1][1]-> [0]:%d [1]:%d [2]:%d\n", arr[1][1][0], arr[1][1][1], arr[1][1][2]);
}
```
arr은 3차원 배열의 주소를 저장하기 위한 포인터 변수로 행과 열의 개수가 \[2\]\[3\]인  
int형 3차원 배열의 시작 주소를 저장한다. 포인터 변수이므로 8바이트이다.  

* 8번
```{.c}
```
int (\*arr\[2\])\[3\]은 포인터 배열로 16바이트 이며,  
iarr1과, iarr2와 같은 변수(1차원의 크기가 3인 2차원 배열)의 주소를 2개 넣을 수 있는 배열을 선언한 것이다.  
다시 말해, 배열 요소(arr\[0\], arr\[1\])은 열의 개수가 \[3\]인 int형 2차원 배열의 시작 주소를 저장한다.  

* 9번
```{.c}

```
arr은 포인터 변수로, 8바이트 이며 iarr1과 iarr2와 같은 주소를 저장한다.  
iarr1과 iarr2와 같은 주소는 int형 주소를 저장하는 열의 개수가 \[3\]개인 배열이다.  
다시 말하지만 **배열**이 아니라 **포인터 변수**다.  
```{.c}
```
```{.c}
```
```{.c}
```

##복잡한 포인터 읽는 방법
다음 URL을 참고하라.

* http://wiki.kldp.org/wiki.php/CLangaugeComplexDeclaration  
* http://unixwiz.net/techtips/reading-cdecl.html (영어)  

##주의: 함수 포인터를 반환하는 함수
함수 포인터를 반환하는 함수는 다른 문법과는 굉장히 상이한 형태를 띄는데,  
어려워 하지 말고, **그냥 외워라**
그럼 함수 포인터를 반환하는 함수의 원형(prototype)에 대해서 알아보자.  


```{.c}
함수포인터반환값자료형 (*함수이름(함수매개변수자료형 매개변수, ...))(함수포인터매개변수자료형, ...)
{
	// ...
}
```
참고로 구별을 쉽게 하기 위해서 이런 습관을 들이면 좋다.  
함수 포인터는 매개변수의 이름을 적지 않아도 컴파일러가 에러를 띄우지 않는다.  
(올바른 문법이라는 뜻이다.)  
따라서 함수 포인터임을 확실히 구별하기 위해서 함수 포인터 매개변수에는 자료형만 쓰고 이름은 쓰지 말자.  


이런 함수를 사용하는 예는 이 디렉토리의 useful_func_ptr.c에 자세하게 나와 있다. 참고하라.   


또한 다음 URL을 참고하면 좋다.

* https://dojang.io/mod/page/view.php?id=600

##함수 포인터를 반환하는 함수의 예시
이런 문법까지 꼭 알고 있어야 할까?  
하지만 임베디드 업종에서 일하거나 커널 코드를 봐야할 상황이 온다면 꼭 알고 있어야 한다.  
또한 C코드를 하나씩 뜯어보다 보면, 다음과 같은 코드를 발견하게 될 것이다.  

```{.c}
#include <signal.h>

// 물론 내부적으로는 typedef를 통해 헷갈리지 않도록 조치를 취해놓았다.
void (*signal(int signo,void (*func)(int)))(int);
```
이런 코드가 나왔을 때 당황하지 않으려면 확실히 익혀 놓아야 한다.  
어쨌든, 해당 함수를 해석해보면 다음과 같다.  


인자로 int signo와 int를 인자로 받고 void를 반환하는 함수 포인터를 받고, <- signal의 인자
인자로 int를 받고 void를 반환하는 함수 포인터를 반환 (<- signal을 반환형)하는 함수 signal


이렇게 선언된 함수는 2가지 형태로 사용할 수 있는데,  
첫째로, signal(a, func)(b);의 형태로 signal함수에도 인자를 넘기고 반환되는 함수 포인터에도 인자를 넘겨 값을 반환받는 방법이 있다.  
이 때 signal을 호출해서 얻게 되는 것은 signal이 반환하는 함수 포인터의 반환값이다.  


둘째로 func1 = signal(a, func2);의 형태로 먼저 함수 포인터 변수에 signal이 반환하는 함수 포인터를 대입하고,  
func1(b);로 함수 포인터를 통해서 함수를 호출하는 형태를 취할수도 있다.

##포인터에 대한 오해와 진실
C나 C++의 포인터는 다른 언어들과는 다르게 연산이 가능하다는 특징을 가지고 있는데,  
정확하게 어떤 타입과 어떤 연산이 가능한지 확실하게 아는가? 아니면 생각해 본적이 있나?  
예를 들어 포인터끼리 더하기 연산을 하려면 반드시 unsigned int형으로 캐스팅 후 더하고,  
다시 해당 포인터 형으로 캐스팅을 해줘야 한다.  


이렇게 포인터에 대해서 잘못 알고 있는 점이 상당히 많은데,  
이번 기회에 확실하게 잡고 넘어가 보자.  

###오해1. 메모리에 접근하려면 포인터가 필수다?  

###오해2. 포인터와 포인터 연산은 +, -연산만 가능하다?  

###오해3. 배열의 이름은 포인터다?  

###오해4. a[]배열의 a와 &a는 같은 의미이다?

###오해5. 배열 첨자에는 0이상의 정수만 들어갈 수 있다?

###오해6. 배열을 함수의 인자로 넘길 수 있다?

##포인터 울렁증 극복하기

###어려운 포인터 해석하기
각종 URL을 참고하여 공부하라.  

###문자열 포인터


###void 포인터


###함수 포인터 배열의 사용예시


