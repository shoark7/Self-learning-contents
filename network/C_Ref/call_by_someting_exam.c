/*
   왜 이런일이 벌어지는지, 다시 말해서 함수 호출원리를 설명하고,
   여기서 스택(스택 프레임)이 무슨역할을 하는지 상세하게 기술할 것!

   서론: C에서 제공하는 문법 *함수*에 관한 의의

   C에서 제공하는 문법 중 가장 중요한 문법 2가지만 뽑아보라고 한다면, 
   변수와 함수가 될 것이다. 변수에 대해서는 일단 넘어가기로 하고 함수에 대해서 살펴보자.
   
   '함수'라는 말은 아마도 수학시간에 처음 접했을 것이다. 하지만 컴퓨터 공학에서 말하는 함수는
   수학적인 함수가 될 수도 있고, 아닐수도 있다. 다시 말해서, 둘은 같지 않다.
   
   프로그래밍 언어에서 함수의 뜻은 다시 2가지로 나눌 수 있는데, 
   1. C와 C-family계열 언어등(명령형 언어)에서 제공하는 함수와
   2. 함수형 언어의 함수가 있다.
   우리가 이 시간에 살펴볼 함수는 1번의 함수이다. 2번의 함수는 기회가 있을 때 다시 살펴보도록한다.

   C에서 제공하는 함수를 확실하게 이해 하려면 서브루틴에 관해서 지식이 필요하다.
   잠깐 공부하고 넘어가도록 하자.

   (참고로 일부 언어에서는 서브루틴과 함수가 다른일을 수행하기 때문에 엄격하게 구분하지만 C는 그렇지 않다.)
   우리가 늘 보는 main함수를 생각해보자. 사실 굳이 함수를 만들거나 할 필요없이,
   main함수에 작성하고자 하는 프로그램의 모든 기능을 전부 넣어서 프로그램을 만들수 있다.
   하지만 누가 그렇게 만드는가? 만들수 있다는 건 누구나 알고 있지만 그렇게 만들면 프로그램이 조금만 커져도 이해하는게 너무 힘들어 지고
   조금만 프로그램을 고치려고 해도 줄줄이 고쳐야하게 된다.

   따라서 사람들은 서브루틴이라는 개념(추상적 개념)을 사용해서 프로그램을 작성하게 된다. 그럼 서브루틴을 뭘까? 서브루틴의 뜻에 대해서 알아보자.
   서브루틴은 따로 사용되지 않고 엔트리 포인트(main 함수)와 결합하여 기능을 수행하며 특정 기능을 반복 수행해야 할 때 주로 사용한다. 

   이 뜻에 맞도록 코드를 작성하고자 한다면 한가지 asm명령을 알고 있어야 하는데 그 주인공은 바로 jmp이다.
   (C에서도 거의 비슷한 뜻을 가지는 명령어가 있는데 그 이름은 goto다.)
   jmp명령은 무조건 주어진 메모리 주소로 실행 지점을 옮기는 명령어다.(코드가 있는 메모리 주소로 무조건 간다고 보면 된다.)
   이 jmp명령을 적절하게 활용한다면 main함수만 사용하더라도 보다 구조적으로 프로그램을 작성할수 있게 된다.

   그러나 jmp만으로는 충분하지 않다. 여러가지 문제점이 있지만 그 중에서도 가장 큰 문제점은 
   서브루틴이 main함수에 종속되기 때문에 그 자체로 독립성을 가지지 못하여 재사용성이 좋지 않고
   프로그램이 쉽게 *스파게티 코드* (프로그램의 흐름이 마구 뒤섞여서 마치 스파게티처럼 꼬여있음)가 되어버린다.

   따라서 대표적인 명령형 언어인 C는 '함수'라는 문법(서브루틴의 일종이라고 보면된다.)을 제공한다.
   뜻을 알아보기 전에, 우리는'함수를 *호출*한다. 함수를 *Call*한다.'와 같은 표현을 사용하는데 
   실제로는 '호출'하는것이 아니라 함수가 시작하는 메모리 주소로 jmp했다가 return을 만나거나 함수 블럭이 끝나면,
   함수 실행을 끝내고 함수 호출 지점으로 '복귀'한다.
   (그렇기 때문에 return이라는 키워드가 있는 것이다. 값을 넘겨서 return이 아니다! 호출 지점으로 복귀하기 때문에 return인 것이다!)

   이제 함수에 관해서 중요한 내용을 하나씩 차근차근 제공하겠다.

   먼저, 함수가 반드시 제공해야 하는 기능을 알아보자.

   0. 함수가 제공하는 기능 3가지

   		0-1. 호출 지점으로 복귀가능해야 한다.(복귀 주소 필요)
			
		0-2. 호출하는 코드(이를 콜러-Caller라 부른다.)와
			 호출되는 함수(불린다는 의미에서 콜리-Callee라고 한다.)간에
			 데이터 교환을 할 수 있어야 한다.
			 즉, 인자를 넘기고 리턴값을 받을 수 있어야 한다.

		0-3. 함수 안에서 또다시 자기 자신을 포함해 
			 어떤 함수든지 부를 수 있도록 함수 호출은 중첩적이야 한다.
			 (이 특징 때문에 StackOverflow Error가 있는것!)

   이런 기능을 제공하는데 활용할 수 있는 최적의 자료구조는 스택이다.
   (스택에 대한 설명이 필요하다면 같은 디렉토리에 들어있는 Stack.txt파일을 살펴보시오.
    여기에는 Stack에 대한 간략한 설명과 스택을 학습하는데 유용한 GNU 유틸리티 dc를 소개한다.)
   따라서 함수에는 스택 프레임(Stack Frame)을 사용해서 함수기능을 구현한다.	

   1. 스택 프레임과 스택 세그먼트의 차이점 
   
   세그먼트에 대해서 공부하기 전에 프로그램에 대해서 잠깐만 공부하고 넘어가도록 하자.

   프로그램은 간단하게 말해서 '실행가능한 파일'이다.
   그리고 프로그램을 만드는 프로그램을 컴파일러 라고 한다.
   (물론 링커 등 다른 프로그램도 있으나 요즘은 컴파일러 하나에 다 들어있는 경우가 많다.
	그리고 인터프리터는 일단 논외로 한다.)
   컴파일러가 프로그램을 만들때 소스코드(사람이 읽을 수 있는 텍스트 파일)만 넘겨줘서 잘 모르는 경우가 많은데,
   사실 프로그램에는 세부적으로 나누어져 있는 많은 정보가 있다. 
   프로그램을 구성하는 정보는 다음과 같다.

   * 바이너리 포맷 식별자: 각 프로그램 파일에는 실행 파일의 포맷에 대한 정보가 포함되어 있다.
     커널은 이를 이용해서 파일의 나머지 정보를 해석한다. 
	 과거의 유닉스 실행 파일에 많이 쓰였던 두 가지 포맷은 a.out('어셈블러 출력')포맷과 
	 나중에 나온, 좀 더 복잡한 COFF(Common Object File Format)였다.
	 요즘은 대부분의 유닉스 구현(리눅스 포함)이 기존 포맷보다 장점이 훨씬 더 많은 
	 ELF(Excutable and Linking Format)를 채택하고 있다.

   * 기계어 명령: 프로그램의 알고리즘을 나타낸다.

   * 프로그램 진입점Entry Point주소: 프로그램이 실행이 시작될 명령의 위치를 나타낸다. 

   * 데이터: 프로그램 파일은 변수의 초기값과 프로그램이 사용할 문자 상수(예: 문자열)를 담고 있다.

   * 심볼 테이블과 재배치 테이블: 프로그램 내 함수와 변수의 위치와 이름을 나타낸다.
     이 테이블은 디버그와 실행 시 심볼 찾기(동적 링크) 등 다양한 목적으로 쓰인다.

   * 공유 라이브러리와 동적 링크 정보: 프로그램 파일에는 실행 시에 필요한 공유 라이브러리 목록과
     이 라이브러리를 로드할 때 사용할 동적 링커의 경로명이 포함되어 있다.

   * 기타 정보: 프로그램 파일에는 프로세스를 만드는데 필요한 그 밖의 여러가지 정보가 포함되어 있다.

   또한 '실행중인 프로그램'을 *프로세스*라고 부르는데,
   이 프로세스에 할당된 메모리도 흔히 *세그먼트*라고 부르는 여러 영역으로 나뉜다.

   세그먼트는 기억장치를 효율적으로 운영하기 위해서 일정한 크기로 나눈 단위이다.
   메모리 세그먼트의 크기를 대체로 고정되지 않으며, 그 크기는 1바이트도 될 수 있다.
   이론적인 크기 제한은 2^64이다.

   프로세스를 구성하는 세그먼트는 다음과 같다.

   * 텍스트(코드) 세그먼트: 프로세스가 실행하는 기계어 명령을 담고 있다.
     텍스트 세그먼트는 읽기 전용이므로 프로세스가 우연히 포인터 값 오류로 스스로의 명령을 변경할 수는 없다.
	 여러 프로세스가 같은 프로그램을 실행할 수 있기 때문에, 
	 텍스트 세그먼트를 공유해 하나의 프로그램 코드를 모든 프로세스의 가상 주소공간에 매핑할 수 있다.

   * 초기화된 텍스트 세그먼트: 명시적으로 초기화된 전역 변수와 정적 변수를 담고 있다.
     이 변수의 값은 프로그램이 메모리에 로드될 때 실행 파일에서 읽는다.

   * 초기화되지 않은 데이터 세그먼트: 명시적으로 초기화되지 않은 전역 변수와 정적 변수를 담고 있다.
  	 프로그램을 시작하기 전에, 시스템은 이 세그먼트 안의 모든 메모리를 0으로 초기화 한다.
	 초기화된 전역 변수와 정적변수를 초기화 되지 않은 것들과 분리된 세그먼트에 넣는 주된 이유는,
	 프로그램이 디스크에 저장할 때, 초기화되지 않은 데이터는 저장하지 않아도 되기 때문이다.
	 대신에 실행 파일은 단순히 초기화되지 않은 데이터 세그먼트의 위치와 크기만 기록하면 되고,
	 해당 공간은 실행시에 프로그램 로더가 할당한다.

   * 스택: 스택은 동적으로 자라고 줄어드는 세그먼트로, 스택 프레임을 담고 있다.
     현재 호출된 각 함수마다 하나의 스택 프레임이 할당된다. 
	 스택 프레임에는 함수의 지역 변수(이른바 자동 변수), 인자, 리턴값이 저장된다.
	 스택 프레임에 대해서는 아래에서 설명한다.
	 (스택은 함수용이라고 생각해도 무방하다.)

	 또한 각 스택에는 다음과 같은 정보가 담겨 있다.

	 	* 함수 인자와 지역 변수: C에서는 함수가 호출될 때 자동으로 만들어지기 때문에 자동 변수automatic variable라고 부른다.
		  또한 함수가 리턴할 때(스택 프레임이 사라지기 때문에) 자동으로 사라지며, 이는 자동 변수와 정적 변수의 주요 차이점이다.
		  정적 변수는 함수의 실행과 무관하게 영구히 존재한다.
		  
		* 호출 연결 정보: 각 함수는 다음에 실행할 기계어 명령을 가리키는 프로그램 카운터program counter같은 CPU레지스터를 사용한다.
		  함수가 다른 함수를 호출할 때 마다, 이 레지스터의 값을 호출된 함수의 스택 프레임에 저장해서 함수 리턴할 때, 
		  호출한 함수를 위해 적절한 레지스터 값을 복원할 수 있다.

   * 힙: 힙은 실행시에 동적으로 (변수용)메모리를 할당하는 영역이다. 
     힙의 꼭대기를 프로그램 브레이크(program break)라고 한다.

   * 스택 프레임:스택 프레임(Stack Frame)이란 함수가
     호출될 때마다 그 함수 호출을 위해 할당 받는 메모리 덩어리를 일컫는다. 
	 특히, 이 스택 프레임은 위에서 말한 몇 가지 구분된 메모리 중 스택 세그먼트에 잡힌다.

   2. 스택 프레임을 사용해서 얻는 이점
   인자 전달 및 복귀주소

   		2-1. 레지스터의 크기는 전체 메모리 크기에 비하면 엄청나게 작은편이다.(아무리 커도 100개 내외)
			 따라서 레지스터만 가지고는 함수(특히 *중첩적인 함수*)를 구현하는데 애로사항이 많이 생기기 때문에 
			 메모리(레지스터 말고)를 스택(Stack)자료구조를 활용하여 인자를 관리하면 레지스터 부족에 시달리지 않아도 된다.

		2-2. 함수가 하나의 모듈로서 독립성을 보장 받으려면
			 인자 이외에는 외부에서 영향을 받으면 안된다.
			 이를 구현하는데는 스택 프레임이 적합하다.

   3. 호출 규약(Calling Convention)

		3-1. stdcall: 스택에 파라미터를 역순으로 삽입하고 함수를 호출한다.
					  스택의 정리작업을 호출된 함수에서 수행한다.
					  파스칼 언어 및 베이직 언어에서 사용하는 방식
					  (C도 일부분 활용한다.)

		3-2. cdecl: 스택에 파라미터를 넣는 방식은 stdcall와 같다.
					단 스택의 정리작업을 호출한 함수에서 수행한다.
					C언어에서 사용하는 방식

		3-3. fastcall: 몇 개의 파라미터는 레지스터를 통해서 넘기고 나머지 파라미터는 스택을 사용하는 방식

		위의 세가지 중에서 보편적인 방식 2가지(그리고 면접에 나온다면 이 두가지의 차이점에 대해서 물어볼 것이다.)는
	    stdcall과 cdecl방식이다. 두 방식의 가장 큰 차이점은 '스택의 정리를 누가 하는가?' 이다.
		
		두 방식의 차이점과 방법의 차이에서 생기는 다른점은 다음과 같다.

		stdcall의 경우 Callee(호출된 함수)에서 스택 정리를 하므로 Caller(호출하는 함수)와 Callee모두
		파라미터(Parameter와 Argument의 차이점도 명확하게 알고 있어야 한다. 부록을 참조하라.)
	    의 개수를 정확하게 알고 있어야 정상적인 처리가 가능하다.

		반면 cdecl 방식 같은 경우 Caller에서 스택 정리를 하므로 Callee는 파라미터의 개수를 정확하게 몰라도 된다.
		바로 이 점이 C언어의 가변인자(Variable argument)를 가능하게 하는 것이다.
		(C에서 ...으로 사용되며 가장 대표적인 예가 printf()가 되겠다.)

		가변인자에 대해서는 나중에 알아보고 우리가 사용할 cdecl에 대해서 자세하게 알아보자.
			
		다음 코드를 보라.
*/
  
int callee(int, int, int);

int caller(void)
{
	int ret;

	ret = callee(1, 2, 3);
	ret += 5;
	return ret;
}

// 다음은 Caller의 asm코드이다.


/*
		여기서 잠깐!

		ebp와 esp, eax, ecx 그리고 몇가지 어셈블리 명령어:
		
		ESP - Extended Stack pointer register: ESP레지스터는 스택의 크기를 조정할 때 사용되는 레지스터이다.
		스택의 최상단 주소를 가지고 있으니 즉 스택의 크기를 나타낸다. 
		어셈블리어의 push 즉 스택에 값을 넣는 동작을 할 때 ESP가 4만큼 감소한다
		(단 이것은 OS의 구현이나 CPU의 아키텍처에 따라서 다를수도 있으니 맹신은 금물이다.)

		EBP - Extended Base pointer register: EBP레지스터는 스택프레임 형태로 저장된 함수의 
		지역변수, 전달인자를 참조하거나 값을 바꾸거나 할 때 사용하는 레지스터이다.
		ESP레지스터로도 참조할 수는 있지만 어셈블리 코드를 유지하기는 힘들다. 
		왜냐하면 EBP는 고정적이지만 ESP는 push, pop, sub, call명령을 수행할 때마다 변하기 때문에
		매번 수정해줘야하는 반면 EBP레지스터를 이용하면 코드유지를 하기 수월해 진다.
		스택프레임이 생성될 때마다 스택프레임의 바닥만 가리켜주면 되기 때문에,
		지역변수나 인자를 참조하기 수월하다.

		esp는 스택의 크기를 나타내기에 왔다갔다 유동적으로 계속 변하며
		ebp는 스택의 기준을 잡아준다.

		EAX - Extended Accmulator Register: 이 레지스터는 산술(덧셈, 곱셈, 나눗셈 등),논리 연산을 수행하며 
		함수의 반환값이 이 레지스터에 저장된다. 즉, 덧셈, 곱셈, 나눗셈 들의 명령은 모두 EAX레지스터를 사용하며
		함수의 반환값이 EAX레지스터에 저장되므로 호출함수의 성공 여부, 실패 여부를 쉽게 파악할 수 있으며, 반환값을 쉽게 얻어올 수 있다.
		(추가로 EBX(Extended Base Register)는 ESI 레지스터나 EDI 레지스터와 결합될 수 있으며, 
		 이 EBX레지스터는 메모리 주소를 저장하기 위한 용도로 사용된다.

		 EDX(Extended Data Register)는 EAX와 같이 쓰이고 부호 확장 명령등에 쓰인다. 
		 큰 수의 곱셈 또는 나눗셈 등의 연산이 이루어질때, EDX 레지스터가 사용되어 EAX 레지스터와 함께 쓰인다.)

		ECX - Extended Counter Register: 이 레지스터는 ECX레지스터로, 말 그대로 카운터 레지스터이다.
		주로 반복 명령어 사용시 반복 카운터로 사용되는 레지스터다. ECX 레지스터에 반복할 횟수를 지정하고 반복 작업을 수행한다.
		이 장에서는 눈에 띄기는해도 사용되지는 않는다.

		기초적인 어셈블리 명령어

		mov A, B : B의 값을 A에 덮어쓴다. =과 같다.

		call X : Stack에 Return Address를 삽입하고 jmp를 수행한다.

		push X : 스택에 값을 저장한다.

		pop X : 스택에서 값을 꺼낸다.

		add A, B : A에 B의 값을 더한다. 즉, A = A + B

		ret, retn : Stack에 포함된 Return Address를 꺼내서 해당 주소로 복귀(보통 call명령과 같이 사용한다.)

 */

/*
caller:
	; make new call frame
	// 새로운 호출 프레임(스택 프레임을 만든다.)
	push    ebp
	mov     ebp, esp

	; push call arguments
	// 호출 인자들을 스택에 집어넣는다. (왼쪽 <- 오른쪽 순서대로 집어넣는다.)
	push    3
	push    2
	push    1

	; call subroutine 'callee'
	// callee 서브루틴(함수를 호출한다.)
	// 다시 말해서 복귀 주소를 스택에 저장하고 서브루틴 시작 주소로 jmp한다.
	call    callee

	; remove arguments from frame
	// 스택을 정리하는 코드
	// cdecl은 caller가 스택을 정리한다. 
	// 따라서 Caller의 코드에서 정리하는 명령어가 보인다.

	// 참고: int형 인자가 3개 였으니까 4*3 = 12
	add     esp, 12

	// 함수의 내용 수행
	; use subroutine result
	add     eax, 5

	// 호출 프레임(해당 스택 프레임)을 제거한다.
	; restore old call frame
	pop     ebp

	// 스택에 들어있는 복귀주소를 활용하여 복귀(jmp)한다.
	; return
	ret

	여기서 주의점은 스택을 정리하는 명령어가 따로 있지는 않다.
	그리고 짚고 넘어가야 할 개념이 있는데, 프롤로그(prologue)와 에필로그(epilogue)다.

	Callee의 스택을 Caller의 스택으로 다시 복원해야 하는데 
	스택 top을 저장하고 복원하는 작업을 프롤로그(prologue), 에필로그(epilogue)라고 한다.
	위에서 본 스택을 복구하는 작업이다.

	만약 우리가 어셈블리어 함수를 만든다면? 그리고 그 함수를 C에서 호출한다면?
	아니면 그 반대의 경우라면 어셈블리어 함수를 어떻게 만들어야 할까? 
	그렇다. 위에서 본 것과 같은 형태 즉 cdecl의 형태를 그대로 따라서 만들면 된다.

	DoSomething() 함수의 프롤로그 에필로그 형태는 아주 일반적인 형태이므로 알아두도록 하자.
	(꼭 저렇게 구성할 필요는 없지만 일반적이므로 알아두자.)

	cdecl의 경우: Caller에서 add 명령어 사용
	ex)add     esp, 12

	stdcall의 경우: Callee에서 retn, ret명령어 부분에서 정리
	ex)retn 08h
*/

/*
	이제 '함수'라는 문법에 대해서는 충분하게 이해 했을거라 믿는다.
	이제 '지역변수' 개념에 대해서 알아보고 파라미터 전달 기법에 대해서 알아보자.

	4. 지역 변수(스코프)

	위에서 언급한 스택 프레임은 인자의 전달과 호출 지점의 복귀를 위해 유용하게 사용되고 있다.
	그런데 스택 프레임은 아주아주 중요한 개념을 구현하는데에도 사용되고 있는데, 
	그 개념은 바로 지역 변수(Local Variable)다.

	함수라는 개념은 그 자체로 독립성을 가지도록 설계되어 있고, 또한 그렇게 동작하는 경우가 많다.
	따라서 독립성을 유지하는데 좋지 않은 전역 변수를 사용하는것 보다는 스택 프레임(즉, 함수를 말한다.)끼리 
	인자를 주고받는(전달하는) 형태를 띄고 있는 것이 독립성을 유지하는데 보다 바람직하다.

	다시 말하지만, 이를 구현하는데 있어서 최적의 자료구조는 바로 스택이다.
	메모리와 스택 프레임을 이용해서 이 자료구조를 구현한다.

	그럼 지역 변수는 '어떻게' 구성할까? 

	call명령어는 스택 프레임에 복귀 주소를 저장하고 callee함수의 위치로 jmp하는 명령어라고 했다.
	따라서 스택 프레임은 복귀주소를 저장하고 있어야 한다.
	여기에 더해서 정보가 하나 더 있는데 그것은 바로 Caller의 ebp 레지스터값이다.
	이 정보도 스택 프레임에 저장하고 함수를 호출한다.

	따라서 미리 Caller의 ebp를 저장하고 해당 서브루틴으로 점프하기 때문에 
	스택 프레임끼리 독립성을 유지할 수 있는 준비는 다 됐다.
	이제 할 일은 무엇인가? ebp와 esp를 적절하게 활용해서 
	스택 프레임끼리 값을 주고 받을 때는 call과 return만 활용하게 구현하면 함수의 독립성을 유지할 수 있게 된다.

	5. Call by value & Call by Reference

	함수의 독립성을 유지하는 것 까지는 좋은데, 불편한 점이 한가지 생겼다.
	현재 스택 프레임에서 다른 스택 프레임의 데이터를 변경하고 싶은 경우가 분명히 있을 것이다.
	하지만 함수는 독립적으로 동작하도록 만들어진 단위이고, 외부 스택에는 변화를 줄 수 없도록 구현되어 있다.
	이 때 포인터가 필요하다.(물론 포인터가 꼭 필요한 이유중 하나가 될 수 있지만, 이 이유만 있는것은 아니다.)

	인자를 넘길때 포인터 형으로 넘긴다면, 결국 스택 프레임에 할당된 값은 *주소*가 된다.
	그리고 포인터 형은 특별한 연산을 사용할 수 있는데, *연산자(역참조 연산자)를 사용하여 함수의 제한에서 벗어나
	현재 스택 프레임 외부의 데이터를 바꿀 수 있게 된다.
*/


#include <stdio.h>

void swap_val(int a, int b) 
{
	int temp = 0;

	temp = a;
	a = b;
	b = a;
}

/*
   swap_val을 호출했을 때 만들어지는 스택구조를 그려서 설명할것

   그리고 괜히 값에 접근하는 것이 아님을 알려줘야 한다.
*/

void swap_ref(int *a, int *b)
{
	int temp = 0;

	temp = *a;
	*a = *b;
	*b = temp;
}

/*
   swap_ref를 호출했을 때 만들어지는 스택구조를 그려서 설명할것
*/


int main (void)
{
	int a = 1;
	int b = 2;

	swap_val(a,b);
	printf("swap_val => a : %d, b : %d\n", a, b);
	
	// 초기화
	a = 1, b = 2;

	swap_ref(&a, &b);
	printf("swap_ref => a : %d, b : %d\n", a, b);
}

/*

	swap을 포인터 주소로 바꾸면 안되는 이유

	출처: http://tikifr.egloos.com/4378956

	아무개씨:

	사용하기에 따라 안되는 코드는 아닌데...왜 이렇게 하는지 모르겠네요. 정석은 이렇습니다.

*/
void Swap(int* p, int* q)
{
	int* r;
	r = p;
	p = q;
	q = r;
}

// p와 q가 포인터형으로 선언되어 있는데 굳이 정수형 변수를 선언해서 스왑을 구현할 이유가 없습니다.

int a = 1;
int b = 2;
p = &a;
q = &b;

/*

	이런 식으로 제대로 주소값이 들어가있다면 잘 수행되지만 null이나 잘못된 값이 들어있으면 뻑나는 코드입니다. 
	포인터형끼리 값을 주고받는데 굳이 '포인터가 가리키는 값'을 교환해야할 이유가 없습니다. 그냥 '포인터'를 교환하면 됩니다. 필요없는 과정을 집어넣지 마세요.

	아무개 저격수:

	완전히 틀렸습니다.
	그런 식으로 짜게 되면 Swap(p, q) 호출해봤자 안 바뀝니다.
	주소값 자체가 pass by value로 복사되어서 넘어가기 때문이죠.

	swap 함수 안에서 패러미터로 넘겨받은 포인터 p와 q 자체를 암만 지지고 볶아봤자 해당 스코프 범위 안에서만 지지고 볶아질 뿐 바깥 스코프에서는 아무런 영향을 받지 않죠. 괜히 값을 바꿔주는게 아닙니다.

	포인터를 교환하고 싶다면.. 굳이 이중포인터로 만들어서 바꾸는 수밖에 없겠는데요.

*/

/*
	포인터가 필요한 이유

	1. 함수를 구현하고 주소에 의한 호출, 값에 의한 호출을 구현하는데 필수적이다. <- 해결!

	2. 각종 (추상)자료구조를 구현하고 활용하는데 거의 필수적인 수준으로 유용하다.

	3. 메모리를 아끼는데 굉장히 유용하다.(주소에 의한 호출)

	4. 데이터를 조작하는데 변수 다음으로 중요한 개념이라고 할 수 있을 정도로 중요하다.
	   특히 데이터를 간접적으로 조작한다는 개념을 길러주는데 필수적이다.
*/


		출처:

		웹페이지:
			 http://redthing.tistory.com/entry/ebp%EC%99%80-esp-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0
			 http://kkamagui.tistory.com/8
			 https://en.wikipedia.org/wiki/X86_calling_conventions
			 https://en.wikipedia.org/wiki/Memory_segmentation

		서적:
			 뇌를 자극하는 프로그래밍 원리 - 한세경: 13장 함수가 호출되기까지
			 누워서 읽는 알고리즘 - 임백준: 188P ~ 195P
			 리눅스 API의 모든것 Vol.1 - 마이클 커리스크: 6장 프로세스


