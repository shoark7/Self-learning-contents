# TCP/IP 스터디 본방

...전송계층은 하위에 있는 실제 전송 작업을 수행하는 하드웨어 관련 계층과 상위에 있는 소프트웨어 기반의 추상적인 계층을 연결하는 중요한 지점이 된다.  

* 재밌는 비유
	* 프로그램: 클래스 템플릿
	* 프로세스: 애플리케이션 인스턴스



* TCP/IP 소프트웨어는 일반적으로 비대칭적이다.
	* FSM적으로 보면 서로 같은 상태를 갖지 않아도 된다.(이것은 이상한것이 아니다.)  



* __애플리케이션 프로세스의 동시성과 데이터의 다중화는 TCP/IP에서 상위 계층 주소지정이 나오게 된 원인이다.__  
* ...이 주소요소는 IP주소 내에서 좀 더 구체적인 위치-소프트웨어 프로세스-를 식별할 수 있도록 한다. TCP/IP에서 이러한 전송 계층 주소를 포트라고 부른다.   



* 포트는 출발지 머신의 출발지 프로세스와 목적지 머신의 목적지 프로세스를 식별한다.  
* 예약 포트번호 != Well-known 포트 번호 -> true

## TCP/UDP 포트번호 범위

* 유명 포트번호(0 ~ 1023)
* 등록(사용자) 포트번호(1024 ~ 49151)
* 사설/동적 포트 번호(49152 ~ 65535)
	* 예약 포트번호는 위 3개의 개념과 완전히 다른 것을 지칭한다!


* pseudo 와 virtual의 차이?
	* pseudo: being apprently rather than as stated
	* virtual: being such in essence or though not formally recognized or admitted


* 동음이의어 소켓
	* 소켓 쌍: TCP연결을 유일하게 구별하는 식별자
	* 소켓: 인터네트워크 상에서 소프트웨어 프로세스를 유일하게 구별하는 식별자
	* 소켓 API: 프로그래머 입장에서 인터네트워크 프로그래밍을 위한 API

## UDP 프로토콜

* UDP 래퍼 프로토콜이다.
* UDP는 기본적으로 전송계층 주소지정이 추가된 IP이다.

### 왜 일부 TCP/IP 애플리케이션이 UDP를 사용하는가?

* 완전성보다 성능이 더 중요한 데이터
* 길이가 짧은 데이터
* ...데이터를 멀티캐스트 또는 브로드캐스트할 필요가 있는 애플리케이션은 UDP를 사용해야 한다. TCP는 유니캐스트밖에 할 수 없다.

## TCP 프로토콜

TCP는 다양한 기능을 갖춘 전송 프로토콜로 일반적인 애플리케이션이 임의의 인터네트워크로 데이터를 신뢰할 수 있게 전송하는데 필요한 기능을 제공한다.


### TCP가 하는 기능

* 주소 지정/다중화
* 연결 수립, 유지, 종료
* 데이터 처리와 패키징(스트림, 세그먼트)
* 데이터 전송(data transmission)
* 신뢰성과 전송 품질 서비스 제공
* 흐름 제어와 혼잡 회피 기능 제공(슬라이딩 윈도우 체계로 제공)

### TCP가 수행하지 않는 기능

* 애플리케이션 사용 명시: TCP는 전송 프로토콜만을 정의한다. 그래서 애플리케이션이 어떻게 TCP를 사용해야 하는지 구체적으로 명시하지 않는다. 그것은 애플리케이션 프로토콜의 몫이다.  
* 보안 제공(다른 수단:IPsec을 사용할 것)
* 메시지 경계 유지(스트림 기반이기 때문에 보장X)
* 통신 보장: TCP는 실제로 통신을 보장할 수 없다. 왜냐하면 TCP의 제어 하에 있지 않은 것이 너무 많기 때문이다. 이와 유사하게, TCP는 데이터 흐름을 관리하려는 시도를 할 수 있지만 모든 흐름 관련 문제를 해결할 수는 없다.  

### TCP 특성

* 연결형: TCP는 장비가 데이터를 송신하기 전에 먼저 연결을 수립할 것을 요구한다.  
* 양방향(full-duplex?): 일단 연결이 수립되면 TCP 장비는 누가 연결을 초기화했는지에 관계없이 데이터를 양방향으로 송수신한다.  
* 다중 연결과 종단 식별: 연결된 두 방지가 사용하는 소켓쌍은 TCP 연결의 종단을 식별한다.  
* 신뢰성(송신한 모든 데이터를 수신했는지 확인하고 데이터 무결성을 검사한 뒤 필요할 경우 재전송한다는 것을 보장할 수 있다.)  
* 승인(TCP가 맡는 모든 바이트에대해서 승인 절차를 진행한다.)  
* 스트림 기반: 대부분의 하위 계층 프로토콜은 상위 계층 프로토콜이 블록 형태로 데이터를 보내도록 요구한다. 반면 TCP는 애플리케이션이 연속적인 데이터 스트림을 송신할 수 있도록 한다. 애플리케이션은 이 스트림을 블록으로 나눈것을 걱정할 필요가 없다. TCP가 그 일을 대신 해 주기 때문이다.
* 구조화되지 않은 데이터: TCP의 스트림 기반 특성은 애플리케이션의 데이터 스트림 내의 데이터 요소를 구분하기 어렵게 한다.  
* 데이터 흐름 관리: TCP는 단순히 데이터를 패키징하여 가능한 빨리 보내는 것 이상의 일을 수행한다. TCP는 데이터가 일정한 속도로 평탄하게 흐르고, 전송 경로 중 발생하는 문제를 처리할 수 있도록 연결을 관리한다.  

> TCP의 핵심 특성은 연결형, 양방향, 다중 연결, 신뢰성, 승인, 스트림 중심, 흐름 관리다.  

### 견고성 원칙

* 견고성 원칙은 "자신이 수행하는 작업은 보수적으로, 다른 사람에게 무언가를 받을 때는 관대하게"로 표현할 수 있다.  
* 이는 방어적 프로그래밍(비관적 프로그래밍?)과도 연관성이 있는 얘기라 할 수 있다.  

## TCP원리와 일반 동작
* TCP는 스트림 중심 프로토콜이다.
	* TCP는 스트림에 승인을 바이트 단위로 한다.(식별을 각 데이터 바이트에 대해 모두 수행해야 한다.)
* 반면 IP는 스트림 중심 프로토콜이 아니라 메시지 중심 프로토콜이다.
	* 그래서 TCP는 애플리케이션에서 오는 스트림을 IP에서 보낼 수 있는 분리된 메시지로 나눠야 한다. 이들 메시지를 TCP 세그먼트라고 부른다.  


* 주의!: MSS는 비대칭적(Asymmetric)이다.  
	* 즉, 클라이언트와 서버의 MSS는 독립적이기 때문에 클라이언트는 서버보다 더 큰 세그먼트를 받을 수도 있고 반대가 될 수도 있다.  



* TCP와 단순한 전송 프로토콜(예:UDP)을 구분하는 것은 장비 간에 데이터를 송신하는 방법의 품질이다.  


* PAR VS 슬라이딩 윈도우 승인 체계
	* PAR은 메시지 단위
	* 스트림 중심 슬라이딩 윈도우 승인 체계는 바이트 단위

* TCP 전송 스트림의 개념적 구분
	* 범주 1: 송신했고 승인이 완료된 바이트
	* 범주 2: 송신했지만 아직 승인되지 않은 바이트
	* 범주 3: 아직 송신하지 않았지만 수신자가 받을 준비를 마친 바이트
	* 범주 4: 아직 송신하지 않았고 수신자가 받을 준비가 안된 바이트

### 순서 번호 할당과 동기화

송신자와 수신자는 스트림의 바이트에 할당할 순서 번호에 동의해야 한다. 이것을 동기화(Synchronization)라고 부르는데, TCP는 연결이 수립될 때 수행한다.  

* 송신 윈도우와 사용가능 윈도우
	* 송신 윈도우와 사용 가능 윈도우의 정의
		* 송신 윈도우는 장비가 한 시점에 송신할 수 있는 최대 승인 받지 않은 데이터(바이트)의 수다.
		* 사용 가능 윈도우는 송신 윈도우 중에서 현재 송신이 가능한 바이트 수다.
	* 슬라이딩 윈도우 체계의 동작에서 핵심이 되는 것은 송신자가 승인받지 않은 데이터를 한 시점에서 얼마나 가질 수 있도록 수신자가 허용하는 지다.
	* 윈도우는 송신자가 전송하도록 허용되어 있는 바이트 수를 결정하며 범주 2와 범주 3에 속한 바이트 수의 합과 같다.

### 엄격한 TCP의 승인 체계

TCP는 오직 하나의 숫자를 이용하여 데이터를 승인하는 승인 체계를 사용한다.

### TCP의 단점

TCP의 단점 중 세그먼트 각각에 대한 승인을 보내지 않기 때문에 수신 장비가 실제로 수신한 세그먼트도 재전송해야 한다는 것이다.

### TCP 순서 번호 동기화

* 승인 번호는 다음에 줘야할 순서 번호
* 순서 번호는 마지막으로 받은 번호

### 초기화란?

TCP가 세그먼트 헤더의 RST플래그를 1로 설정하여 보내는 것을 말한다.  

### 장비가 연결 종료?

장비가 연결을 종료한다는 것은 그 장비는 더 이상 데이터를 보내지 않는 것일 뿐이므로,   
상대 방비가 원할 때까지 데이터를 계속 받아야 한다. 그래야 두 장비의 연결이 종료되기 전에 보내야 할 데이터를 모두 방출할 수 있다.  

### TCP 메시지 포맷과 데이터 송신

TCP 세그먼트는 제어 정보와 데이터를 동시에 송신할 수 있다.  

| 필드명                   | 크기(바이트) | 설명                                                                                                                                                                                                                                          |
|--------------------------|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 순서 번호                | 4            | 정상적인 송신일 경우 이 세그먼트에서 보내는 첫 번째 바이트의 순서 번호가 연결 요청(SYN) 메시지일 경우에는 출발지 TCP가 사용할 ISN(Initial Sequence Number)이다. 실제로 보낼 첫 번째 데이터 바이트는 이 필드의 값+1을 순서 번호 값으로 가진다. |
| 식별자                   | 4            | ACK비트가 설정되면 세그먼트는 승인 기능을 가진다. 그리고 이 필드는 출발지가 다음에 목적지로 보내야 할 데이터의 순서 번호를 가진다. 자세한 내용은 48장을 참조하자.                                                                             |
| 데이터 오프셋(헤더 길이) | 1/2          |                                                                                                                                                                                                                                               |
| 예약                     | 3/4          |                                                                                                                                                                                                                                               |
| 제어비트                 | 3/4          | 각각 1비트씩, SYN, ACK, FIN, PSH, RST, ARG 6가지 필드가 준비되어있다.                                                                                                                                                                         |
| 윈도우                   | 2            |                                                                                                                                                                                                                                               |
| 체크섬                   | 2            |                                                                                                                                                                                                                                               |

* urgent와 push에는 이런 차이가 있다.
	* 밀어넣기는 그 세그먼트를 통째로 PUSH하는 것
	* urgent는 긴급한 데이터 부위만 보내는 것

## 가상 헤더(Pseudo Header) 사용의 장점

* 다음과 같은 문제를 방지할 수 있다.
	* 잘못된 세그먼트 송신
	* 잘못된 프로토콜
	* 잘못된 세그먼트 길이

> 참고: TCP 가상 헤더는 실용성을 위해 엄격한 계층 구조를 무너뜨린 예다.(절대는 없다.)

## TCP 최대 세그먼트 크기

* 윈도우가 아무리 크더라도 최대 세그먼트 크기(MSS)를 넘을 수는 없다.
* 최대 세그먼트 크기라고 하는 이름은 오해하기 쉽다. MSS는 실제로는 세그먼트가 가질 수 있는 데이터의 최대 양을 뜻한다.  
	* 만약 MSS가 100이라고 한다면 실제로 최대 세그먼트 크기는 120이나(일반적인 헤더를 사용한다면(일반적인 TCP헤더의 크기는 20바이트)) 더 커질수도 있다.(만약 TCP 선택사항을 가진다면)  


* MSS는 왜 헤더를 포함하지 않는가?
	* MSS는 연결할 때만 사용
	* 헤더길이는 유동적이다.
	* 그렇기 때문에 헷갈리지 않기 위해서 데이터만(!) 이라는 조건을 내건 것이다.  


## MSS 선택

MSS는 TCP/IP 네트워크에서 데이터를 송신하는 것과 관련된 다양한 성능과 구현 문제 간의 균형을 이루게 선택되어야 한다.  
MSS 선택 시에는 다음과 같은 사항을 고려해야 한다.  

* 과부화 관리
* IP 단편화


## TCP 기본 MSS

모든 네트워크는 576바이트의 IP 데이터그램을 단편화 없이 처리할 수 있다.  
따라서 TCP에서 사용하는 표준 MSS는 536바이트다.  

## TCP/IP 애플리케이션 주소 지정: 유일 자원 식별자(URI, URN, URN)

* URL은 웹과 함께 시작되었으며 아직까지도 대부분이 HTTP에서 사용된다.
* 스킴(Scheme)이라는 말은 자원을 사용하는 방법인 접근 방식을 나타낸다.
	* 스킴에 슬래시가 2개 있는 이유는 팀 버너스 리의 실수에서 비롯되었다. 사실 슬래시는 1개만 있어도 된다.  
	* 팀 버너스 리 경은 이것때문에 사과했다고 한다.  
* URL에서 특수부호화 문자가 많이 뜨는 이유는 URL이 한글을 지원하지 않아서 이를 표현하려다 보니 생기는 현상이다.
	* 정확하게 말하자면 ASCII를 기본 인코딩 테이블로 사용하기 때문이다.  
* 스킴에 따라서 URL의 다른 컴포넌트의 배열이나 표현방식이 달라진다.  
	* file:///... <- 왜 이렇게 쓰는지 이제 알겠는가? 맨 앞의 자원을 식별하기 위해 경로가 표시된다.  
	* 따라서 맨 뒤에 있는 슬래시는 스킴 식별자가 아니라 루트 경로를 나타내는 것이다.
* URL의 최대 길이는 브라우저에 종속적이다.  

## 절대 URL과 상대 URL

* 절대 URL은 문맥 독립적(content dependent)이다.
* 상대 URL은 문맥 종속적(content independent)이다.  

## 다음 시간까지

* III-8부를 위주로 한다.
* 시간과 여력이 허락한다면 III-1부도 해온다.
* 그래도 시간이 남는다면 58장, 87장, 88장까지 해오자.
































